<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[g3gg0.de] ESP32 Firmware Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            color: #d4d4d4;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1f35 0%, #1c1424 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1900px;
            margin: 0 auto;
            background: #2a2a2a;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #3d4a7a 0%, #2d1f3d 100%);
            color: #e0e0e0;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .drop-zone {
            border: 3px dashed #5a6bb8;
            border-radius: 10px;
            padding: 10px 10px;
            text-align: center;
            background: #333333;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .drop-zone:hover {
            background: #3a3f5a;
            border-color: #7a6bb8;
        }

        .drop-zone.drag-over {
            background: #404560;
            border-color: #8a7bc8;
            transform: scale(1.02);
        }

        .drop-zone i {
            font-size: 4em;
            color: #7a8bdc;
            margin-bottom: 20px;
            display: block;
        }

        .drop-zone p {
            font-size: 1.2em;
            color: #a0a0a0;
            margin: 10px 0;
        }

        .drop-zone .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #5a6bb8 0%, #6a5294 100%);
            color: #e8e8e8;
            border: none;
            padding: 12px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(90, 107, 184, 0.5);
        }

        .file-info {
            background: #333333;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .file-info.visible {
            display: block;
        }

        .file-info h3 {
            color: #7a8bdc;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            background: #252525;
            padding: 5px 8px;
            border-radius: 5px;
            border-left: 3px solid #5a6bb8;
        }

        .info-item label {
            font-weight: bold;
            color: #9a9a9a;
            font-size: 0.9em;
            display: block;
            margin-bottom: 5px;
        }

        .info-item span {
            color: #c8c8c8;
            font-size: 1em;
            word-break: break-all;
        }

        .size-selector {
            cursor: pointer;
            text-decoration: underline dotted;
            color: #6ec589;
        }

        .size-selector:hover {
            color: #8bf0a8;
        }

        .size-select {
            background: #252525;
            color: #c8c8c8;
            border: 1px solid #5a6bb8;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 0.95em;
            outline: none;
        }

        .size-select:focus {
            border-color: #8bf0a8;
            box-shadow: 0 0 0 2px rgba(139, 240, 168, 0.2);
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid #404040;
            margin-bottom: 20px;
            gap: 10px;
        }

        .tab {
            padding: 15px 30px;
            background: #2a2a2a;
            border: none;
            cursor: pointer;
            font-size: 1em;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s ease;
        }

        .tab:hover {
            background: #3a3a3a;
        }

        .tab.active {
            background: linear-gradient(135deg, #3d4565 0%, #3a2e4a 100%);
            color: #e8e8e8;
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #2d2d2d;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        th {
            background: linear-gradient(135deg, #3d4565 0%, #3a2e4a 100%);
            color: #e0e0e0;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 4px 4px;
            border-bottom: 1px solid #404040;
        }

        tr:hover {
            background: #383840;
        }

        tr:last-child td {
            border-bottom: none;
        }

        .fat-file-row {
            cursor: pointer;
        }

        .fat-file-row:hover {
            background: #3d3e48;
            box-shadow: inset 0 0 10px rgba(100, 100, 255, 0.2);
        }

        .expandable {
            cursor: pointer;
        }

        .expandable:hover {
            background: #3d3e48;
        }

        .details-row {
            display: none;
            background: #333338;
        }

        .details-row.visible {
            display: table-row;
        }

        .details-content {
            padding: 15px;
            border-left: 3px solid #5a6bb8;
        }

        .details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .detail-item {
            background: #3a3a3a;
            padding: 4px 8px;
            border-radius: 5px;
        }

        .detail-item strong {
            color: #7a8bdc;
            display: block;
            margin-bottom: 5px;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
            background: #404040;
        }

        .badge.app {
            color: #6b9aeb;
        }

        .badge.data {
            color: #b883d8;
        }

        .badge.nvs {
            color: #f39c63;
        }

        .badge.fat {
            color: #6ec589;
        }

        .code-block {
            background: #1e1e1e;
            color: #7a8bdc;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            margin: 10px 0;
        }

        .nvs-namespace {
            background: linear-gradient(90deg, #5a6bb8 0%, #6a5294 100%);
            color: #e8e8e8;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 5px;
            font-weight: bold;
        }

        .nvs-item {
            background: #2d2d2d;
            padding: 5px 8px;
            margin: 5px 0;
            border-left: 3px solid #5a6bb8;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .nvs-item:hover {
            background: #353535;
        }

        .nvs-item .mono {
            word-break: break-all;
            display: inline-block;
            max-width: calc(100% - 100px);
        }

        .nvs-item.crc-bad {
            border-left-color: #e57373;
            background: #3a2b2b;
        }

        .nvs-delete-btn {
            background: #c05050;
            color: #ffffff;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            position: absolute;
            right: 8px;
            top: 8px;
        }

        .nvs-delete-btn:hover {
            background: #d06060;
        }

        .nvs-add-btn {
            background: #5a6bb8;
            color: #ffffff;
            border: none;
            padding: 4px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 8px;
        }

        .nvs-add-btn:hover {
            background: #6a7bc8;
        }

        .nvs-edit-btn {
            background: #63d437;
            color: #ffffff;
            border: none;
            padding: 2px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9em;
            position: absolute;
            right: 40px;
            top: 8px;
        }

        .nvs-edit-btn:hover {
            background: #e0af47;
        }

        .nvs-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #5a6bb8;
            border-radius: 8px;
            padding: 20px;
            z-index: 10001;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            min-width: 400px;
        }

        .nvs-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
        }

        .nvs-popup h3 {
            margin-bottom: 15px;
            color: #7a8bdc;
        }

        .nvs-popup label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
            font-weight: bold;
            color: #c8c8c8;
        }

        .nvs-popup input,
        .nvs-popup select {
            width: 100%;
            padding: 8px;
            border: 1px solid #5a6bb8;
            border-radius: 4px;
            background: #333333;
            color: #d4d4d4;
            font-size: 1em;
        }

        .nvs-popup-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .crc-info {
            font-size: 0.85em;
            color: #b0b0b0;
            margin-top: 4px;
        }

        .crc-info .bad {
            color: #e57373;
            font-weight: 600;
        }

        .crc-info .ok {
            color: #81c784;
            font-weight: 600;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7a8bdc;
            font-size: 1.2em;
        }

        .error {
            background: #3d1f1f;
            color: #e88888;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #c05050;
            margin: 10px 0;
        }

        .success {
            background: #1f3d24;
            color: #88d899;
            padding: 15px;
            border-radius: 5px;
            border-left: 3px solid #50a05e;
            margin: 10px 0;
        }

        .mono {
            font-family: 'Courier New', monospace;
            background: #3a3a3a;
            color: #d0d0d0;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .download-btn {
            background: #4d8f52;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .download-btn:hover {
            background: #5aa05e;
        }

        .replace-btn {
            background: #8f4d4d;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .replace-btn:hover {
            background: #a05a5a;
        }

        .hex-btn {
            background: #5a6bb8;
            color: #e8e8e8;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin: 5px;
        }

        .hex-btn:hover {
            background: #6a7bc8;
        }

        .hex-viewer {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .hex-line {
            display: flex;
            margin: 2px 0;
        }

        .hex-offset {
            color: #7a8bb8;
            margin-right: 15px;
            min-width: 80px;
        }

        .hex-bytes {
            color: #88d899;
            margin-right: 15px;
            flex: 1;
        }

        .hex-ascii {
            color: #d4a574;
        }

        .hex-controls {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .hex-controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .hex-controls input {
            width: 100%;
            padding: 8px;
            border: 1px solid #5a5a5a;
            border-radius: 4px;
            background: #2a2a2a;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
        }

        /* Fetch overlay */
        #fetchOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .fetch-overlay-box {
            background: #1f1f1f;
            color: #e0e0e0;
            padding: 20px 28px;
            border-radius: 10px;
            border: 1px solid #444;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
            text-align: center;
            min-width: 260px;
        }

        .fetch-overlay-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .fetch-overlay-text {
            font-size: 14px;
            color: #c9d1d9;
        }

        /* Write overlay (red accent) */
        #writeOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .write-overlay-box {
            background: #2a1f1f;
            color: #e0e0e0;
            padding: 20px 28px;
            border-radius: 10px;
            border: 1px solid #c44;
            box-shadow: 0 10px 30px rgba(200, 50, 50, 0.45);
            text-align: center;
            min-width: 260px;
        }

        .write-overlay-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            color: #ff6b6b;
        }

        .write-overlay-text {
            font-size: 14px;
            color: #ffcccc;
        }

        /* Device status display */
        #deviceStatusText {
            font-size: 14px;
            padding: 15px;
            border-radius: 5px;
            background: #252525;
            border-left: 4px solid #6ec589;
            word-break: break-word;
            white-space: pre-wrap;
        }

        #deviceStatusText.success {
            border-left-color: #6ec589;
            color: #a8e6b8;
        }

        #deviceStatusText.error {
            border-left-color: #ff6b6b;
            background: #3a2020;
            color: #ffb3b3;
        }

        #deviceStatusText.loading {
            border-left-color: #5a8fd8;
            background: #202540;
            color: #7aafff;
        }

        /* Memory map visualization */
        #memoryMapContainer {
            margin-bottom: 20px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            display: none;
        }

        #memoryMapContainer h4 {
            margin: 0 0 10px 0;
            color: #7a8bdc;
            font-size: 14px;
        }

        #memoryMap {
            width: 100%;
            height: 40px;
            background: #1a1a1a;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            border: 1px solid #444;
        }

        .memory-segment {
            position: absolute;
            height: 100%;
            top: 0;
            transition: all 0.3s ease;
        }

        .memory-segment.unread {
            background: #3a3a3a;
        }

        .memory-segment.cached {
            background: linear-gradient(180deg, #4CAF50 0%, #2e7d32 100%);
        }

        .memory-segment.modified {
            background: linear-gradient(180deg, #f44336 0%, #b71c1c 100%);
        }

        #memoryMapLegend {
            display: flex;
            gap: 20px;
            margin-top: 8px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid #555;
        }

        .legend-color.unread {
            background: #3a3a3a;
        }

        .legend-color.cached {
            background: #4CAF50;
        }

        .legend-color.modified {
            background: #f44336;
        }

        /* Device popup */
        .device-popup {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 31, 53, 0.95);
            border: 1px solid #4a4f70;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            padding: 12px 14px;
            border-radius: 8px;
            color: #f0f6fc;
            font-size: 14px;
            max-width: 440px;
            z-index: 1000;
            display: none;
            line-height: 1.4;
        }

        .device-popup strong {
            color: #7a8bdc;
        }

        @keyframes blink-red {
            0%, 100% { box-shadow: 0 0 0 rgba(0,0,0,0); }
            50% { box-shadow: 0 0 12px rgba(248, 81, 73, 0.8); }
        }

        .device-popup.secure-warning {
            border-color: #f85149;
            background: rgba(62, 12, 12, 0.95);
            color: #fff;
            animation: blink-red 1s linear infinite;
        }
    </style>
</head>

<body>
    <div id="fetchOverlay">
        <div class="fetch-overlay-box">
            <div class="fetch-overlay-title">Fetching firmwareâ€¦</div>
            <div class="fetch-overlay-text" id="fetchOverlayText">Please wait</div>
        </div>
    </div>
    <div id="writeOverlay">
        <div class="write-overlay-box">
            <div class="write-overlay-title">Writing to Deviceâ€¦</div>
            <div class="write-overlay-text" id="writeOverlayText">Please wait</div>
        </div>
    </div>
    <div id="devicePopup" class="device-popup"></div>
    <div class="container">
        <div class="header">
            <h1>[g3gg0.de] ESP32 Firmware Editor</h1>
            <p>Analyze ESP32 firmware images - View partitions, NVS data, and file systems</p>
        </div>

        <div class="content">
            <div class="drop-zone" id="dropZone">
                <p><strong>Drop your ESP32 firmware (.bin) file here</strong></p>
                <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
                    <button class="btn" onclick="document.getElementById('fileInput').click()">Browse Files</button>
                    <button class="btn" id="connectToggleBtn"
                        style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);"
                        onclick="toggleDeviceSession()">Connect to ESP32</button>
                </div>
                <input type="file" id="fileInput" class="file-input" accept=".bin">
            </div>

            <div class="file-info" id="fileInfo">
                <h3>ðŸŽ¯ Target Information</h3>
                <div class="info-grid" id="fileInfoGrid">
                </div>
                <div id="targetActions" style="display:none; margin-top:12px;">
                    <div class="button-group" style="flex-wrap:wrap; gap:8px;display: none;">
                        <button class="btn" id="targetResetBtn" onclick="deviceHardReset()" disabled>Reset</button>
                        <button class="btn" id="targetSyncBtn" onclick="deviceSync()" disabled>Sync</button>
                        <button class="btn" id="targetStubBtn" onclick="deviceLoadStub()" disabled>Download
                            Stub</button>
                        <button class="btn" id="targetFetchBtn" onclick="deviceFetch()" disabled>Refresh</button>
                    </div>
                </div>
                <div class="button-group" style="display: flex; flex-wrap:wrap; gap:8px;">
                    <button class="btn" id="deviceDisconnectBtn" onclick="toggleDeviceSession()"
                        style="background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%); display: none;">Disconnect</button>
                    <button class="btn" id="writeToDeviceBtn" onclick="writeToDevice()"
                        style="display: none; background: linear-gradient(135deg, #b71c1c 0%, #ef5350 100%);">Write to
                        Device</button>
                    <button class="btn" id="saveImageBtn" onclick="saveImage()">Save Image</button>
                </div>
            </div>

            <div id="deviceStatusContainer" style="display: none; margin-bottom: 20px;">
                <div id="deviceStatusText" class="success"
                    style="padding: 15px; border-radius: 5px; background: #252525; border-left: 4px solid #6ec589;">
                </div>
            </div>

            <div id="memoryMapContainer">
                <h4>ðŸ“Š Memory Map</h4>
                <div id="memoryMap" style="cursor: pointer;" title="Click to show segments in console"></div>
                <div id="memoryMapLegend">
                    <div class="legend-item">
                        <div class="legend-color unread"></div>
                        <span>Unread</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color cached"></div>
                        <span>Cached</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color modified"></div>
                        <span>Modified</span>
                    </div>
                </div>
            </div>

            <div id="tabContainer" style="display: none;">
                <div style="display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 10px;">
                </div>
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('bootloader', event)">Bootloader</button>
                    <button class="tab" onclick="switchTab('partitions', event)">Partitions</button>
                    <button class="tab" onclick="switchTab('raw', event)">Hex Viewer</button>
                </div>

                <div class="tab-content active" id="bootloader-tab">
                    <h3>Bootloader</h3>
                    <div id="bootloaderContent"></div>
                </div>

                <div class="tab-content" id="partitions-tab">
                    <h3>Partition Table</h3>
                    <div id="partitionsContent"></div>
                </div>

                <div class="tab-content" id="nvs-tab">
                    <h3>Non-Volatile Storage (NVS)</h3>
                    <div id="nvsContent"></div>
                </div>

                <div class="tab-content" id="raw-tab">
                    <h3>Hex Viewer</h3>
                    <div class="hex-controls">
                        <div>
                            <label for="hexOffset">Offset (hex):</label>
                            <input type="text" id="hexOffset" value="0" placeholder="0x0" onchange="updateHexView()">
                        </div>
                        <div>
                            <label for="hexLength">Length (hex):</label>
                            <input type="text" id="hexLength" value="100" placeholder="0x100"
                                onchange="updateHexView()">
                        </div>
                        <div>
                            <label for="hexWidth">Width (bytes/line):</label>
                            <input type="number" id="hexWidth" value="32" min="4" max="64" step="4"
                                onchange="updateHexView()">
                        </div>
                        <div style="display: flex; align-items: flex-end;">
                            <button class="btn" onclick="updateHexView()">Update View</button>
                        </div>
                    </div>
                    <div id="rawContent"></div>
                </div>
            </div>

            <input type="file" id="partitionFileInput" class="file-input" style="display:none" accept=".bin">
        </div>
    </div>

    <script src="chips.js"></script>
    <script src="flasher.js"></script>
    <!-- Load NVS parser before ESP32 parser to enable delegation -->
    <script src="nvs-parser.js"></script>
    <script src="esp32-parser.js"></script>
    <script>
        let parser = null;
        let currentFile = null;
        let replaceTargetPartition = null;

        let deviceFlasher = null;
        let deviceMode = false;
        let deviceSparse = null;
        let devicePopupTimer = null;
        let devicePopupContent = '';
        let deviceFlashSizeBytes = 0x00800000; /* Default 8 MiB */
        let deviceReadProgressTotal = 0;
        let deviceReadProgressDone = 0;
        let fetchOverlayReason = '';
        let fetchOverlayActiveReads = 0;
        let intentionalDisconnect = false; /* Track intentional disconnects */
        let bootloaderInfo = null;
        let partitionTableOffset = null;

        /* Performance tracking for read/write operations */
        let readStartTime = null;
        let readSlowWarningShown = false;
        let readWarningShownTime = null;
        let readWarningHideTimeout = null;
        let writeStartTime = null;
        let writeSlowWarningShown = false;
        let writeWarningShownTime = null;
        let writeWarningHideTimeout = null;
        const SLOW_SPEED_THRESHOLD = 200 * 1024; /* 200 KiB/s in bytes/s */
        const SPEED_CHECK_DELAY = 5000; /* 1 second before checking speed */
        const WARNING_MIN_DISPLAY_TIME = 10000; /* Keep warning visible for at least 10 seconds */

        function buildDeviceSparse(totalSize, logReads = false) {
            return new SparseImage(totalSize,
                async (readAddr, readLen) => {
                    const addr = readAddr & ~0x0FFF;
                    const maxChunk = 0x00800000;
                    const desired = Math.min(readLen, maxChunk);
                    let len = (desired + 0x1000) & ~0x0FFF;

                    /* Ensure we don't read beyond configured flash size */
                    if (addr >= totalSize) {
                        throw new Error(`Read address 0x${addr.toString(16)} exceeds flash size 0x${totalSize.toString(16)}`);
                    }
                    len = Math.min(len, totalSize - addr);
                    if (len <= 0) {
                        throw new Error(`Invalid read length at address 0x${addr.toString(16)}`);
                    }

                    if (logReads) {
                        console.log('  Reading', `0x${addr.toString(16)}`, len);
                    }
                    const overlayWasVisible = isFetchOverlayVisible();
                    fetchOverlayActiveReads++;
                    if (!overlayWasVisible) {
                        showFetchOverlay(fetchOverlayReason || 'Reading flash from ESP32...');
                    }
                    const readTotal = len;
                    try {
                        updateFetchOverlayProgress(addr, 0, readTotal);
                        const ret = await deviceFlasher.readFlashPlain(addr, len, (bytesRead, totalBytes) => {
                            const effectiveTotal = totalBytes || readTotal;
                            updateFetchOverlayProgress(addr + bytesRead, bytesRead, effectiveTotal);
                        });
                        deviceReadProgressDone += ret.byteLength;
                        updateFetchOverlayProgress(addr + ret.byteLength, readTotal, readTotal);
                        const chunk = { address: addr, data: ret };
                        if (logReads) {
                            console.log('  Got', `0x${addr.toString(16)}`, ret.byteLength, chunk);
                        }
                        /* Update memory map after successful read */
                        setTimeout(() => updateMemoryMap(), 100);
                        return chunk;
                    } finally {
                        fetchOverlayActiveReads = Math.max(0, fetchOverlayActiveReads - 1);
                        if (!overlayWasVisible && fetchOverlayActiveReads === 0) {
                            hideFetchOverlay();
                        }
                    }
                },
                async (writeAddr, writeData) => {
                    /* Write callback for flushing changes to device */
                    if (logReads) {
                        console.log('  Writing', `0x${writeAddr.toString(16)}`, writeData.length, 'bytes');
                    }
                    if (writeAddr % 0x1000 !== 0) {
                        throw new Error(`Write address 0x${writeAddr.toString(16)} is not aligned to 0x1000 bytes`);
                    }
                    if (writeData.length % 0x1000 !== 0) {
                        throw new Error(`Write data length ${writeData.length} is not aligned to 0x1000 bytes`);
                    }
                    await deviceFlasher.writeFlash(writeAddr, writeData, (offset, total, status) => {
                        updateWriteOverlayProgress(writeAddr + offset, offset, total);
                    });
                    if (logReads) {
                        console.log('  Wrote', `0x${writeAddr.toString(16)}`, writeData.length, 'bytes');
                    }
                },
                async (sparseImage) => {
                    /* Flush prepare callback: combine cached and write data into 0x1000-byte blocks */
                    if (logReads) {
                        console.log('Flush prepare: consolidating write buffer into 4KB-aligned blocks');
                    }

                    if (sparseImage.writeBuffer.length === 0) return;

                    /* Get the range we need to cover */
                    let minAddr = Infinity;
                    let maxAddr = 0;

                    for (const seg of sparseImage.writeBuffer) {
                        minAddr = Math.min(minAddr, seg.address);
                        maxAddr = Math.max(maxAddr, seg.address + seg.data.length);
                    }

                    if (minAddr === Infinity) return; /* Nothing to do */

                    /* Align to 0x1000 byte boundaries */
                    const blockStart = minAddr & ~0x0FFF;
                    const blockEnd = (maxAddr + 0x0FFF) & ~0x0FFF;

                    if (logReads) {
                        console.log(`Prepare: processing range 0x${blockStart.toString(16)} - 0x${blockEnd.toString(16)}`);
                    }

                    /* Build aligned blocks: prefer writeBuffer-only materialization; otherwise read via sparse image */
                    const blockMap = new Map(); /* blockAddr -> blockData */

                    for (let blockAddr = blockStart; blockAddr < blockEnd; blockAddr += 0x1000) {
                        const blockEndAddr = blockAddr + 0x1000;

                        const overlaps = [];
                        for (const seg of sparseImage.writeBuffer) {
                            const segStart = seg.address;
                            const segEnd = seg.address + seg.data.length;
                            const overlapStart = Math.max(blockAddr, segStart);
                            const overlapEnd = Math.min(blockEndAddr, segEnd);
                            if (overlapStart < overlapEnd) {
                                overlaps.push({ start: overlapStart, end: overlapEnd, seg });
                            }
                        }

                        overlaps.sort((a, b) => a.start - b.start);

                        let coveredCursor = blockAddr;
                        for (const ov of overlaps) {
                            if (ov.start > coveredCursor) {
                                break;
                            }
                            if (ov.end > coveredCursor) {
                                coveredCursor = ov.end;
                            }
                            if (coveredCursor >= blockEndAddr) {
                                break;
                            }
                        }

                        const fullyCovered = coveredCursor >= blockEndAddr;
                        let blockData;

                        if (fullyCovered) {
                            blockData = new Uint8Array(0x1000);
                            blockData.fill(0xFF);
                            for (const ov of overlaps) {
                                const srcOff = ov.start - ov.seg.address;
                                const dstOff = ov.start - blockAddr;
                                const len = ov.end - ov.start;
                                blockData.set(ov.seg.data.slice(srcOff, srcOff + len), dstOff);
                            }
                        } else {
                            blockData = await sparseImage.slice_async(blockAddr, blockEndAddr);
                        }

                        blockMap.set(blockAddr, blockData);
                    }

                    /* Merge touching/consecutive blocks */
                    const mergedBlocks = [];
                    const blockAddrs = Array.from(blockMap.keys()).sort((a, b) => a - b);

                    let currentStart = null;
                    let currentData = null;

                    for (const blockAddr of blockAddrs) {
                        if (currentStart === null) {
                            /* Start new merged block */
                            currentStart = blockAddr;
                            currentData = new Uint8Array(blockMap.get(blockAddr));
                        } else if (currentStart + currentData.length === blockAddr) {
                            /* Consecutive block: merge it */
                            const mergedData = new Uint8Array(currentData.length + 0x1000);
                            mergedData.set(currentData, 0);
                            mergedData.set(blockMap.get(blockAddr), currentData.length);
                            currentData = mergedData;
                        } else {
                            /* Gap detected: save current merged block and start new one */
                            mergedBlocks.push({ address: currentStart, data: currentData });
                            if (logReads) {
                                console.log(`  Merged block at 0x${currentStart.toString(16)}, size: ${currentData.length} bytes`);
                            }
                            currentStart = blockAddr;
                            currentData = new Uint8Array(blockMap.get(blockAddr));
                        }
                    }

                    /* Add final merged block */
                    if (currentStart !== null) {
                        mergedBlocks.push({ address: currentStart, data: currentData });
                        if (logReads) {
                            console.log(`  Merged block at 0x${currentStart.toString(16)}, size: ${currentData.length} bytes`);
                        }
                    }

                    /* Replace write buffer with merged blocks */
                    sparseImage.writeBuffer = mergedBlocks;

                    if (logReads) {
                        console.log(`Flush prepare complete: ${mergedBlocks.length} blocks aligned and ready`);
                    }

                    /* Update memory map after prepare */
                    setTimeout(() => updateMemoryMap(), 100);
                }
            );
        }

        async function openFlasherMenu() {
            await toggleDeviceSession();
        }

        async function toggleDeviceSession() {
            const btn = document.getElementById('connectToggleBtn');
            const isDisconnect = btn && btn.dataset.state === 'connected';

            if (isDisconnect) {
                await disconnectDeviceSession();
                return;
            }

            try {
                setDeviceStatus('Requesting serial port...', 'loading');
                deviceFlasher = new ESPFlasher();

                /* Set up callback for unexpected device disconnection */
                deviceFlasher.disconnected = () => {
                    handleUnexpectedDeviceDisconnect();
                };

                deviceFlasher.deviceStateCallback = (state, data) => {
                    const msg = formatDeviceStateMessage(state, data);
                    showDevicePopup(msg, state);
                };

                await deviceFlasher.openPort();
                setDeviceButtons({ connected: true });

                setDeviceStatus('Resetting ESP32...', 'loading');
                await deviceFlasher.hardReset(true);

                setDeviceStatus('Syncing...', 'loading');
                await deviceFlasher.sync();
                const isStub = await deviceFlasher.isStubLoader();
                setDeviceButtons({ connected: true, synced: true, stub: isStub });

                if (!isStub) {
                    setDeviceStatus('Loading stub...', 'loading');
                    const stubLoaded = await deviceFlasher.downloadStub();
                    setDeviceButtons({ connected: true, synced: true, stub: stubLoaded });
                }

                setDeviceStatus('Fetching bootloader and partition table...', 'loading');
                setFetchOverlayReason('Reading flash from ESP32');
                showFetchOverlay('Reading flash from ESP32...');
                deviceMode = true;
                deviceReadProgressTotal = deviceFlashSizeBytes;
                deviceReadProgressDone = 0;
                const totalSize = deviceFlashSizeBytes;
                deviceSparse = buildDeviceSparse(totalSize, false);

                parser = new ESP32Parser(deviceSparse);
                displayFileInfo({
                    name: 'ESP32 Device',
                    size: totalSize,
                    type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                    lastModified: Date.now()
                });

                await parseAndDisplay(true);
                setDeviceStatus('Connected to ' + deviceFlasher.current_chip + '. Firmware loaded and parsed.', 'success');
                setToggleButtonState(true);

                /* Hide file drop/browse when in device mode */
                const dropZone = document.getElementById('dropZone');
                if (dropZone) dropZone.style.display = 'none';
            } catch (e) {
                setDeviceStatus('Connection failed: ' + e.message, 'error');
                setDeviceButtons({ connected: false });
                setToggleButtonState(false);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
                /* Update memory map after all reads complete */
                updateMemoryMap();
            }
        }

        async function disconnectDeviceSession() {
            intentionalDisconnect = true;
            if (deviceFlasher) {
                try {
                    await deviceFlasher.disconnect();
                } catch (e) {
                    console.warn('Device disconnect error:', e);
                }
            }

            clearDeviceState();
        }

        function handleUnexpectedDeviceDisconnect() {
            /* Called when device is unexpectedly disconnected (pulled out, lost connection, etc) */
            if (!intentionalDisconnect) {
                setDeviceStatus('Device unexpectedly disconnected. Please reconnect.', 'error');
            }
            clearDeviceState();
        }

        function clearDeviceState() {
            /* Clear all device information and reset to disconnected state */
            deviceFlasher = null;
            deviceSparse = null;
            deviceMode = false;
            parser = null;
            currentFile = null;

            setDeviceButtons({ connected: false, synced: false, stub: false });
            setToggleButtonState(false);

            /* Hide file info section */
            const fileInfo = document.getElementById('fileInfo');
            if (fileInfo) {
                fileInfo.classList.remove('visible');
            }

            /* Hide tab container */
            const tabContainer = document.getElementById('tabContainer');
            if (tabContainer) {
                tabContainer.style.display = 'none';
            }

            /* Hide memory map */
            const memoryMapContainer = document.getElementById('memoryMapContainer');
            if (memoryMapContainer) {
                memoryMapContainer.style.display = 'none';
            }

            /* Clear content in all tabs */
            const contentDivs = document.querySelectorAll('[id$="Content"]');
            contentDivs.forEach(div => {
                div.innerHTML = '';
            });

            /* Keep Save Image button visible even when disconnected */
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) {
                saveBtn.style.display = 'inline-block';
            }

            /* Show file drop/browse when disconnected */
            const dropZone = document.getElementById('dropZone');
            if (dropZone) dropZone.style.display = 'block';

            const popup = document.getElementById('devicePopup');
            if (popup) {
                popup.style.display = 'none';
                popup.classList.remove('secure-warning');
            }
            devicePopupContent = '';
            if (devicePopupTimer) {
                clearTimeout(devicePopupTimer);
                devicePopupTimer = null;
            }
        }

        /**
         * Update memory map visualization
         */
        function updateMemoryMap() {
            if (!parser) return;

            const container = document.getElementById('memoryMapContainer');
            const map = document.getElementById('memoryMap');

            if (!container || !map) return;

            /* Show the map */
            container.style.display = 'block';

            /* Clear existing segments */
            map.innerHTML = '';

            let totalSize = 0;
            let readBuffer = [];
            let writeBuffer = [];

            /* Get data based on mode */
            if (parser.sparseImage) {
                /* Device mode or sparse image */
                totalSize = parser.sparseImage.size;
                readBuffer = parser.sparseImage.readBuffer || [];
                writeBuffer = parser.sparseImage.writeBuffer || [];
            } else {
                container.style.display = 'none';
                return;
            }

            /* Create a coverage map */
            const segmentSize = Math.max(1, Math.floor(totalSize / 1000)); /* 1000 segments max */
            const segments = [];

            for (let i = 0; i < totalSize; i += segmentSize) {
                const end = Math.min(i + segmentSize, totalSize);
                segments.push({ start: i, end: end, type: 'unread' });
            }

            /* Mark cached regions (readBuffer) */
            for (const read of readBuffer) {
                const readStart = read.address;
                const readEnd = read.address + read.data.length;

                for (let seg of segments) {
                    if (seg.end <= readStart || seg.start >= readEnd) continue;
                    seg.type = 'cached';
                }
            }

            /* Mark modified regions (writeBuffer) - these override cached */
            for (const write of writeBuffer) {
                const writeStart = write.address;
                const writeEnd = write.address + write.data.length;

                for (let seg of segments) {
                    if (seg.end <= writeStart || seg.start >= writeEnd) continue;
                    seg.type = 'modified';
                }
            }

            /* Render segments - merge adjacent segments of same type to avoid gaps */
            const mergedSegments = [];
            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                if (mergedSegments.length > 0 && mergedSegments[mergedSegments.length - 1].type === seg.type) {
                    /* Extend previous segment */
                    mergedSegments[mergedSegments.length - 1].end = seg.end;
                } else {
                    /* New segment */
                    mergedSegments.push({ start: seg.start, end: seg.end, type: seg.type });
                }
            }

            for (const seg of mergedSegments) {
                const div = document.createElement('div');
                div.className = `memory-segment ${seg.type}`;
                const leftPercent = (seg.start / totalSize) * 100;
                const widthPercent = ((seg.end - seg.start) / totalSize) * 100;
                div.style.left = leftPercent + '%';
                div.style.width = widthPercent + '%';
                div.title = `0x${seg.start.toString(16).toUpperCase()} - 0x${seg.end.toString(16).toUpperCase()} (${seg.type})`;
                map.appendChild(div);
            }

            /* Add click handler to show segments in console */
            map.onclick = () => {
                console.log('=== Memory Map Segments ===');
                console.log(`Total Size: 0x${totalSize.toString(16).toUpperCase()} (${formatBytes(totalSize)})`);
                console.log('\nRead Buffer Segments:');
                readBuffer.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.address.toString(16).toUpperCase()} - 0x${(seg.address + seg.data.length).toString(16).toUpperCase()} (${formatBytes(seg.data.length)})`);
                });
                console.log('\nWrite Buffer Segments:');
                writeBuffer.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.address.toString(16).toUpperCase()} - 0x${(seg.address + seg.data.length).toString(16).toUpperCase()} (${formatBytes(seg.data.length)})`);
                });
                console.log('\nMerged Display Segments:');
                mergedSegments.forEach((seg, idx) => {
                    console.log(`  [${idx}] 0x${seg.start.toString(16).toUpperCase()} - 0x${seg.end.toString(16).toUpperCase()} (${seg.type})`);
                });
            };
        }

        function setToggleButtonState(connected) {
            const btn = document.getElementById('connectToggleBtn');
            if (!btn) return;
            if (connected) {
                btn.textContent = 'Disconnect';
                btn.style.background = 'linear-gradient(135deg, #b71c1c 0%, #ef5350 100%)';
                btn.dataset.state = 'connected';
            } else {
                btn.textContent = 'Connect to ESP32';
                btn.style.background = 'linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%)';
                btn.dataset.state = 'disconnected';
            }
        }

        function setDeviceButtons({ connected = false, synced = false, stub = false }) {
            const targetActions = document.getElementById('targetActions');
            if (targetActions) {
                targetActions.style.display = connected ? 'block' : 'none';
            }

            const btnReset = document.getElementById('targetResetBtn');
            const btnSync = document.getElementById('targetSyncBtn');
            const btnStub = document.getElementById('targetStubBtn');
            const btnFetch = document.getElementById('targetFetchBtn');
            const btnDisconnect = document.getElementById('deviceDisconnectBtn');

            if (btnReset) btnReset.disabled = !connected;
            if (btnSync) btnSync.disabled = !connected;
            if (btnStub) btnStub.disabled = !synced || stub;
            if (btnFetch) btnFetch.disabled = !synced;
            if (btnDisconnect) btnDisconnect.style.display = connected ? 'block' : 'none';
        }

        function setDeviceStatus(text, cls = 'success') {
            const el = document.getElementById('deviceStatusText');
            const container = document.getElementById('deviceStatusContainer');
            if (el && container) {
                el.className = cls;
                el.textContent = text;
                container.style.display = 'block';
                container.style.opacity = '1';
                container.style.transition = 'opacity 0.5s ease-out';

                /* Fade out after 5 seconds */
                setTimeout(() => {
                    container.style.opacity = '0';
                    setTimeout(() => {
                        container.style.display = 'none';
                    }, 500);
                }, 5000);
            } else {
                console.log(`[${cls}] ${text}`);
            }
        }

        function showDevicePopup(message, state = null) {
            const popup = document.getElementById('devicePopup');
            if (!popup) {
                return;
            }

            if (popup.style.display !== 'none' && devicePopupContent) {
                devicePopupContent += '\n' + message;
            } else {
                devicePopupContent = message;
            }

            popup.innerHTML = '<strong>Device Info</strong><br>' + devicePopupContent.replace(/\n/g, '<br>');
            if (state === 'secure') {
                popup.classList.add('secure-warning');
            } else {
                popup.classList.remove('secure-warning');
            }
            popup.style.display = 'block';

            if (devicePopupTimer) {
                clearTimeout(devicePopupTimer);
            }
            devicePopupTimer = setTimeout(() => {
                popup.style.display = 'none';
                devicePopupContent = '';
            }, 5000);
        }

        function formatDeviceStateMessage(state, data) {
            if (state === 'secure') {
                return 'âš ï¸ Warning: Device is secured, this tool won\'t work with it';
            }
            if (state === 'download') {
                return 'Device waiting for download (ROM bootloader)';
            }
            if (state === 'reboot' && data) {
                const rstHex = '0x' + (data.rst ?? 0).toString(16);
                const rstName = data.rstName || 'UNKNOWN';
                const bootHex = '0x' + (data.boot ?? 0).toString(16);
                return `Reboot: ${rstName} (${rstHex}), boot=${bootHex}`;
            }
            return `Device state: ${state}`;
        }

        function showFetchOverlay(text) {
            const overlay = document.getElementById('fetchOverlay');
            const label = document.getElementById('fetchOverlayText');
            if (label) {
                label.textContent = text || fetchOverlayReason || 'Fetching firmware...';
            }
            if (overlay) {
                overlay.style.display = 'flex';
            }
            readStartTime = Date.now();
            readSlowWarningShown = false;
        }

        function setFetchOverlayReason(reason) {
            fetchOverlayReason = reason || '';
            const overlay = document.getElementById('fetchOverlay');
            const label = document.getElementById('fetchOverlayText');
            if (overlay && label && overlay.style.display === 'flex') {
                label.textContent = fetchOverlayReason || label.textContent || 'Fetching firmware...';
            }
        }

        function isFetchOverlayVisible() {
            const overlay = document.getElementById('fetchOverlay');
            return overlay && overlay.style.display === 'flex';
        }

        function updateFetchOverlayProgress(address, bytesRead, totalBytes) {
            const label = document.getElementById('fetchOverlayText');
            if (!label) {
                return;
            }

            const kbRead = Math.round(bytesRead / 1024);
            const kbTotal = Math.round(totalBytes / 1024);
            const pct = totalBytes > 0 ? Math.min(100, Math.round((bytesRead / totalBytes) * 100)) : 0;

            let text = `Reading 0x${address.toString(16).toUpperCase()} (${pct}% â€“ ${kbRead} / ${kbTotal} KB)`;
            let addWarning = false;

            /* Calculate speed if operation has been running > 1 second */
            if (readStartTime) {
                const elapsedMs = Date.now() - readStartTime;
                if (elapsedMs > SPEED_CHECK_DELAY && bytesRead > 0) {
                    const speedBytesPerSec = (bytesRead / elapsedMs) * 1000;
                    const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                    text += ` - ${speedKiBPerSec} KiB/s`;

                    /* Show warning if speed is too slow */
                    if (speedBytesPerSec < SLOW_SPEED_THRESHOLD) {
                        addWarning = true;
                        if (!readSlowWarningShown) {
                            readSlowWarningShown = true;
                            readWarningShownTime = Date.now();
                        }
                    }
                }
            } else if (readSlowWarningShown && readWarningShownTime) {
                /* Keep showing warning if still within minimum display time */
                const warningElapsedMs = Date.now() - readWarningShownTime;
                if (warningElapsedMs < WARNING_MIN_DISPLAY_TIME) {
                    addWarning = true;
                }
            }
            if (addWarning) {
                text += `<br><br>âš ï¸ SLOW: due to hardware/stub bug, ESP32-S3 and C3 are very slow with onchip USB-JTAG`;
            }

            label.innerHTML = text;
        }

        function hideFetchOverlay() {
            const overlay = document.getElementById('fetchOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            fetchOverlayActiveReads = 0;
            readStartTime = null;
            /* Clear any existing timeout and set new one for warning minimum display time */
            if (readWarningHideTimeout) {
                clearTimeout(readWarningHideTimeout);
            }
            if (readSlowWarningShown && readWarningShownTime) {
                const timeElapsed = Date.now() - readWarningShownTime;
                const timeRemaining = Math.max(0, WARNING_MIN_DISPLAY_TIME - timeElapsed);
                readWarningHideTimeout = setTimeout(() => {
                    readSlowWarningShown = false;
                    readWarningShownTime = null;
                    readWarningHideTimeout = null;
                }, timeRemaining);
            }
        }

        function showWriteOverlay(text) {
            const overlay = document.getElementById('writeOverlay');
            const label = document.getElementById('writeOverlayText');
            if (label) {
                label.textContent = text || 'Writing to device...';
            }
            if (overlay) {
                overlay.style.display = 'flex';
            }
            writeStartTime = Date.now();
            writeSlowWarningShown = false;
            writeWarningShownTime = null;
        }

        function updateWriteOverlayProgress(address, bytesWritten, totalBytes) {
            const label = document.getElementById('writeOverlayText');
            if (!label) {
                return;
            }

            const kbWritten = Math.round(bytesWritten / 1024);
            const kbTotal = Math.round(totalBytes / 1024);
            const pct = totalBytes > 0 ? Math.min(100, Math.round((bytesWritten / totalBytes) * 100)) : 0;

            let text = `Writing 0x${address.toString(16).toUpperCase()} (${pct}% â€“ ${kbWritten} / ${kbTotal} KB)`;
            let addWarning = false;

            /* Calculate speed if operation has been running > 1 second */
            if (writeStartTime) {
                const elapsedMs = Date.now() - writeStartTime;
                if (elapsedMs > SPEED_CHECK_DELAY && bytesWritten > 0) {
                    const speedBytesPerSec = (bytesWritten / elapsedMs) * 1000;
                    const speedKiBPerSec = Math.round(speedBytesPerSec / 1024);
                    text += ` - ${speedKiBPerSec} KiB/s`;

                    /* Show warning if speed is too slow */
                    if (speedBytesPerSec < SLOW_SPEED_THRESHOLD) {
                        addWarning = true;
                        if (!writeSlowWarningShown) {
                            writeSlowWarningShown = true;
                            writeWarningShownTime = Date.now();
                        }
                    }
                }
            } else if (writeSlowWarningShown && writeWarningShownTime) {
                /* Keep showing warning if still within minimum display time */
                const warningElapsedMs = Date.now() - writeWarningShownTime;
                if (warningElapsedMs < WARNING_MIN_DISPLAY_TIME) {
                    addWarning = true;
                }
            }
            if (addWarning) {
                text += `<br><br>âš ï¸ SLOW: due to hardware/stub bug, ESP32-S3 and C3 are very slow with onchip USB-JTAG`;
            }

            label.innerHTML = text;
        }

        function hideWriteOverlay() {
            const overlay = document.getElementById('writeOverlay');
            if (overlay) {
                overlay.style.display = 'none';
            }
            writeStartTime = null;
            /* Clear any existing timeout and set new one for warning minimum display time */
            if (writeWarningHideTimeout) {
                clearTimeout(writeWarningHideTimeout);
            }
            if (writeSlowWarningShown && writeWarningShownTime) {
                const timeElapsed = Date.now() - writeWarningShownTime;
                const timeRemaining = Math.max(0, WARNING_MIN_DISPLAY_TIME - timeElapsed);
                writeWarningHideTimeout = setTimeout(() => {
                    writeSlowWarningShown = false;
                    writeWarningShownTime = null;
                    writeWarningHideTimeout = null;
                }, timeRemaining);
            }
        }

        async function deviceConnect() {
            try {
                setDeviceStatus('Requesting serial port...', 'loading');
                deviceFlasher = new ESPFlasher();
                await deviceFlasher.openPort();
                setDeviceStatus('Connected. You may Hard Reset, then Sync.', 'success');
                setDeviceButtons({ connected: true });
            } catch (e) {
                setDeviceStatus('Connection failed: ' + e.message, 'error');
                setDeviceButtons({ connected: false });
            }
        }

        async function deviceHardReset() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Resetting...', 'loading');
                await deviceFlasher.hardReset(true);
                setDeviceStatus('Reset sequence sent.', 'success');
            } catch (e) {
                setDeviceStatus('Reset failed: ' + e.message, 'error');
            }
        }

        async function deviceSync() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Syncing...', 'loading');
                await deviceFlasher.sync();
                setDeviceStatus('Synced to ' + deviceFlasher.current_chip + '.', 'success');
                setDeviceButtons({ connected: true, synced: true, stub: await deviceFlasher.isStubLoader() });
            } catch (e) {
                setDeviceStatus('Sync failed: ' + e.message, 'error');
            }
        }

        async function deviceLoadStub() {
            if (!deviceFlasher) return;
            try {
                setDeviceStatus('Loading stub...', 'loading');
                const ok = await deviceFlasher.downloadStub();
                setDeviceButtons({ connected: true, synced: true, stub: ok });
                setDeviceStatus(ok ? 'Stub loaded.' : 'Stub load failed', ok ? 'success' : 'error');
            } catch (e) {
                setDeviceStatus('Stub error: ' + e.message, 'error');
            }
        }

        async function deviceFetch() {
            if (!deviceFlasher) return;
            try {
                deviceMode = true;
                setDeviceStatus('Fetching bootloader and partition table...', 'loading');
                setFetchOverlayReason('Reading flash from ESP32');
                showFetchOverlay('Reading flash from ESP32...');
                deviceReadProgressTotal = deviceFlashSizeBytes;
                deviceReadProgressDone = 0;
                const totalSize = deviceFlashSizeBytes;
                deviceSparse = buildDeviceSparse(totalSize, false);

                parser = new ESP32Parser(deviceSparse);

                /* Fake file info for UI */
                displayFileInfo({
                    name: 'ESP32 Device',
                    size: totalSize,
                    type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                    lastModified: Date.now()
                });

                await parseAndDisplay();
                setDeviceStatus('Fetched and parsed. You can explore partitions.', 'success');
            } catch (e) {
                setDeviceStatus('Fetch failed: ' + e.message, 'error');
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        // File drop handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');

            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        const partitionFileInput = document.getElementById('partitionFileInput');
        partitionFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0 && replaceTargetPartition !== null) {
                handlePartitionReplaceFile(e.target.files[0], replaceTargetPartition);
            }
        });

        async function handleFile(file) {
            currentFile = file;

            /* If in device mode, compare and write changes to sparse image */
            if (deviceMode && deviceSparse && parser) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        showFetchOverlay('Comparing file with device memory...');
                        const fileData = new Uint8Array(e.target.result);
                        const fileSize = fileData.length;

                        /* Compare file data with cached read segments */
                        let modifiedRegions = [];

                        if (deviceSparse.readBuffer.length === 0) {
                            /* No cached data - write entire file at offset 0 */
                            modifiedRegions.push({ start: 0, end: fileSize });
                        } else {
                            /* Compare with cached regions */
                            for (const segment of deviceSparse.readBuffer) {
                                const segStart = segment.address;
                                const segEnd = Math.min(segStart + segment.data.length, fileSize);

                                if (segStart >= fileSize) continue;

                                /* Compare this segment with file data */
                                let regionStart = null;
                                let regionEnd = null;

                                for (let i = segStart; i < segEnd; i++) {
                                    const deviceByte = segment.data[i - segStart];
                                    const fileByte = fileData[i];

                                    if (deviceByte !== fileByte) {
                                        if (regionStart === null) {
                                            regionStart = i;
                                        }
                                        regionEnd = i + 1;
                                    } else {
                                        if (regionStart !== null) {
                                            modifiedRegions.push({ start: regionStart, end: regionEnd });
                                            regionStart = null;
                                            regionEnd = null;
                                        }
                                    }
                                }

                                /* Close any open region */
                                if (regionStart !== null) {
                                    modifiedRegions.push({ start: regionStart, end: regionEnd });
                                }
                            }
                        }

                        /* Write modified regions to sparse image */
                        let totalModified = 0;
                        for (const region of modifiedRegions) {
                            const length = region.end - region.start;
                            const data = fileData.slice(region.start, region.end);
                            deviceSparse.write(region.start, data);
                            totalModified += length;
                        }

                        hideFetchOverlay();

                        if (totalModified > 0) {
                            setDeviceStatus(`File loaded. ${modifiedRegions.length} modified region(s) detected (${formatBytes(totalModified)} changed). Use "Write to Device" to commit.`, 'success');
                        } else {
                            setDeviceStatus('File loaded. No differences detected with cached device memory.', 'success');
                        }

                        /* Update memory map and re-parse */
                        updateMemoryMap();
                        await parseAndDisplay(true);
                    } catch (error) {
                        hideFetchOverlay();
                        showError('Error comparing file: ' + error.message);
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                /* Normal file mode - disconnect device and load file via SparseImage */
                await disconnectDeviceSession();
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const sparse = SparseImage.fromBuffer(e.target.result);
                        parser = new ESP32Parser(sparse);
                        displayFileInfo(file);
                        parseAndDisplay(true).then(() => {
                            updateMemoryMap();
                        }).catch(err => showError('Error parsing file: ' + err.message));
                    } catch (error) {
                        showError('Error parsing file: ' + error.message);
                    }
                };
                reader.readAsArrayBuffer(file);
            }
        }

        function displayFileInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const grid = document.getElementById('fileInfoGrid');

            const typeLabel = (() => {
                const t = file.type || 'application/octet-stream';
                if (t.startsWith('device/') && deviceFlasher && deviceFlasher.current_chip) {
                    return `device/${deviceFlasher.current_chip}`;
                }
                return t;
            })();

            const isDevice = deviceMode || (file.type && file.type.startsWith('device/'));
            const sizeValueBytes = isDevice ? deviceFlashSizeBytes : file.size;
            const sizeMarkup = isDevice
                ? `<select id="deviceSizeSelect" class="size-select" title="Select device flash size">
                        <option value="1">1 MiB</option>
                        <option value="2">2 MiB</option>
                        <option value="4">4 MiB</option>
                        <option value="8">8 MiB</option>
                        <option value="16">16 MiB</option>
                   </select>`
                : `<span>${formatBytes(sizeValueBytes)}</span>`;

            grid.innerHTML = `
                <div class="info-item">
                    <label>Filename</label>
                    <span>${file.name}</span>
                </div>
                <div class="info-item">
                    <label>Size</label>
                    ${sizeMarkup}
                </div>
                <div class="info-item">
                    <label>Type</label>
                    <span>${typeLabel}</span>
                </div>
                <div class="info-item">
                    <label>Last Modified</label>
                    <span>${new Date(file.lastModified).toLocaleString()}</span>
                </div>
            `;

            if (isDevice) {
                const sel = document.getElementById('deviceSizeSelect');
                if (sel) {
                    const currentMiB = Math.round(deviceFlashSizeBytes / (1024 * 1024));
                    sel.value = String(currentMiB);
                    sel.addEventListener('change', () => {
                        const parsed = parseInt(sel.value, 10);
                        applyDeviceFlashSize(parsed * 1024 * 1024);
                    });
                }
            }

            fileInfo.classList.add('visible');

            // Show/hide Write to Device button based on device mode
            const writeBtn = document.getElementById('writeToDeviceBtn');
            if (writeBtn) {
                writeBtn.style.display = isDevice ? 'inline-block' : 'none';
            }

            // Always show Save Image button for both file and device modes
            const saveBtn = document.getElementById('saveImageBtn');
            if (saveBtn) {
                saveBtn.style.display = 'inline-block';
            }
        }

        async function applyDeviceFlashSize(sizeBytes) {
            if (!deviceFlasher) {
                return;
            }

            deviceFlashSizeBytes = sizeBytes;
            deviceMode = true;

            setFetchOverlayReason('Applying flash size');
            showFetchOverlay('Applying flash size...');
            try {
                deviceSparse = buildDeviceSparse(deviceFlashSizeBytes, false);
                parser = new ESP32Parser(deviceSparse);
                displayFileInfo({
                    name: 'ESP32 Device',
                    size: deviceFlashSizeBytes,
                    type: `device/${deviceFlasher.current_chip || 'esp32'}`,
                    lastModified: Date.now()
                });

                await parseAndDisplay(true);
                setDeviceStatus('Flash size set to ' + (deviceFlashSizeBytes / (1024 * 1024)) + ' MiB.', 'success');
            } catch (e) {
                alert('Error applying flash size: ' + e.message);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        async function parseAndDisplay(focusBootloader = false) {
            // Parse bootloader first to detect partition table offset
            bootloaderInfo = await parseBootloader(0x0000);
            if(!bootloaderInfo || bootloaderInfo.error) {
                bootloaderInfo = await parseBootloader(0x1000);
            }
            console.log("Bootloader parsed:", bootloaderInfo);

            // Auto-detect partition table offset based on bootloader end/FF padding
            const detectedOffset = await parser.detectPartitionTableOffset(bootloaderInfo);
            console.log("Detected partition table offset: ", detectedOffset ? `0x${detectedOffset.toString(16)}` : 'not found');

            partitionTableOffset = detectedOffset;
            detectedOffset && await parser.parsePartitions(detectedOffset);

            // Compute SHA-1 only in file mode to avoid heavy device reads
            if (!deviceMode) {
                await Promise.all(parser.partitions.map(async (part) => {
                    part.sha1 = await parser.computePartitionSHA1(part);
                }));
            }

            await displayPartitions();

            // Show tabs
            document.getElementById('tabContainer').style.display = 'block';

            if (focusBootloader) {
                switchTab('bootloader');
            }
        }

        async function parseBootloader(offset = 0x0000) {
            const contentDiv = document.getElementById('bootloaderContent');
            // We don't know the partition table offset yet, so use a reasonable max search size
            const maxBootloaderLength = 0x10000; // 64KB should be more than enough for any bootloader
            const partition = { offset: offset, length: maxBootloaderLength, label: 'bootloader' };

            contentDiv.innerHTML = '<div class="loading">â³ Parsing bootloader...</div>';

            try {
                const image = await parser.parseImage(partition.offset, partition.length);

                // Validate SHA256 (appended) and compute region/full hashes
                let sha256Validation = null;
                let sha256Calculated = null;
                let sha256RegionCalc = null;

                const calcSliceEnd = Math.min(partition.offset + partition.length, parser.buffer.length);
                if (calcSliceEnd > partition.offset) {
                    const calcData = parser.buffer.slice(partition.offset, calcSliceEnd);
                    const calcHash = await ESP32Parser.calculateSHA256(calcData);
                    sha256Calculated = ESP32Parser.bytesToHex(calcHash);
                }

                if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined && image.sha256DataEnd > image.sha256DataStart) {
                    console.log(`Bootloader SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);
                    const regionData = parser.buffer.slice(image.sha256DataStart, image.sha256DataEnd);
                    const regionHash = await ESP32Parser.calculateSHA256(regionData);
                    sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                }

                if (image.sha256) {
                    sha256Validation = await parser.validateImageSHA256(image);
                    if (sha256Validation && !sha256Validation.calculated && sha256RegionCalc) {
                        sha256Validation.calculated = sha256RegionCalc;
                    }
                }

                let html = '';

                if (image.error) {
                    html = `<div class="error">${image.error}</div>`;
                } else {
                    html = '<div class="success">Bootloader parsed successfully</div>';

                    html += '<h4 style="margin-top: 15px;">Basic Information</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Bootloader Offset:</label><span class="mono">0x${offset.toString(16).toUpperCase().padStart(4, '0')}</span></div>`;
                    html += `<div class="info-item"><label>Magic:</label><span class="mono">0x${image.magic.toString(16).toUpperCase()}</span></div>`;
                    html += `<div class="info-item"><label>Segment Count:</label><span>${image.segmentCount}</span></div>`;
                    html += `<div class="info-item"><label>Entry Address:</label><span class="mono">0x${image.entryAddr.toString(16).toUpperCase().padStart(8, '0')}</span></div>`;
                    html += `<div class="info-item"><label>Chip:</label><span>${image.chipName} (0x${image.chipId.toString(16).toUpperCase().padStart(4, '0')})</span></div>`;
                    html += '</div>';

                    html += '<h4 style="margin-top: 15px;">Flash Configuration</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>SPI Mode:</label><span>${image.spiModeName} (${image.spiMode})</span></div>`;
                    html += `<div class="info-item"><label>SPI Speed:</label><span>${image.spiSpeedName}</span></div>`;
                    html += `<div class="info-item"><label>Flash Size:</label><span>${image.spiSizeName}</span></div>`;
                    html += `<div class="info-item"><label>WP Pin:</label><span>${image.wpPinDisabled ? 'Disabled (0xEE)' : '0x' + image.wpPin.toString(16).toUpperCase()}</span></div>`;
                    html += '</div>';

                    // App Description (if found)
                    if (image.appDesc && image.appDesc.found) {
                        html += '<h4 style="margin-top: 15px;">Application Description</h4>';
                        html += '<div class="info-grid">';
                        if (image.appDesc.projectName) {
                            html += `<div class="info-item"><label>Project Name:</label><span>${image.appDesc.projectName}</span></div>`;
                        }
                        if (image.appDesc.version) {
                            html += `<div class="info-item"><label>Version:</label><span>${image.appDesc.version}</span></div>`;
                        }
                        if (image.appDesc.idfVer) {
                            html += `<div class="info-item"><label>ESP-IDF Version:</label><span>${image.appDesc.idfVer}</span></div>`;
                        }
                        html += `<div class="info-item"><label>Secure Version:</label><span>${image.appDesc.secureVersion}</span></div>`;
                        if (image.appDesc.date && image.appDesc.time) {
                            html += `<div class="info-item"><label>Build Date/Time:</label><span>${image.appDesc.date} ${image.appDesc.time}</span></div>`;
                        }
                        if (image.appDesc.appElfSha256) {
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>App ELF SHA256:</label><span class="mono" title="Reference only - ELF file not available for validation">${image.appDesc.appElfSha256} <span style="color: #9a9a9a;">â„¹ï¸</span></span></div>`;
                        }
                        html += '</div>';
                    }

                    html += '<h4 style="margin-top: 15px;">Validation</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Checksum:</label><span class="mono">0x${(image.checksum || 0).toString(16).toUpperCase().padStart(2, '0')}</span></div>`;
                    html += `<div class="info-item"><label>Hash Appended:</label><span>${image.hasHash ? 'Yes' : 'No'}</span></div>`;
                    if (image.sha256) {
                        const validIcon = sha256Validation && sha256Validation.valid ?
                            '<span style="color: #6ec589; font-size: 1.2em;" title="Hash verified over header..checksum region">âœ“</span>' :
                            sha256Validation && sha256Validation.valid === false ?
                                '<span style="color: #e88888; font-size: 1.2em;" title="' + sha256Validation.reason + '">âœ—</span>' :
                                '<span style="color: #9a9a9a; font-size: 1.2em;" title="Validating...">â³</span>';
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Image SHA256 (appended):</label><span class="mono">${image.sha256} ${validIcon}</span></div>`;
                    }
                    if (sha256RegionCalc) {
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Region SHA256 (header..checksum):</label><span class="mono">${sha256RegionCalc}</span></div>`;
                    }
                    if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                        const regionLen = image.sha256DataEnd - image.sha256DataStart;
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Hash region:</label><span class="mono">0x${image.sha256DataStart.toString(16).toUpperCase()} - 0x${image.sha256DataEnd.toString(16).toUpperCase()} (${regionLen} bytes)</span></div>`;
                    }
                    if (sha256Calculated) {
                        html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Calculated SHA256 (full bootloader region):</label><span class="mono">${sha256Calculated}</span></div>`;
                        if (image.sha256 && sha256Validation && sha256Validation.valid === false && sha256Validation.calculated) {
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Expected vs Calc (region):</label><span class="mono" style="color: #e88888;">${sha256Validation.expected} â‰  ${sha256Validation.calculated}</span></div>`;
                        }
                    }
                    html += '</div>';

                    html += '<h4 style="margin-top: 15px;">Segments</h4>';
                    html += '<table><thead><tr><th>#</th><th>Load Address</th><th>Length</th><th>Offset</th></tr></thead><tbody>';
                    image.segmentList.forEach((seg, sidx) => {
                        html += '<tr>';
                        html += `<td>${sidx}</td>`;
                        html += `<td class="mono">0x${seg.loadAddress.toString(16).toUpperCase().padStart(8, '0')}</td>`;
                        html += `<td>${formatBytes(seg.length)}</td>`;
                        html += `<td class="mono">0x${seg.offset.toString(16).toUpperCase()}</td>`;
                        html += '</tr>';
                    });
                    html += '</tbody></table>';

                    html += '<h4 style="margin-top: 15px;">Actions</h4>';
                    html += '<div style="display: flex; gap: 10px; flex-wrap: wrap;">';
                    html += '<button class="hex-btn" onclick="viewPartitionHex(-1)">Hex View</button>';
                    html += '<button class="download-btn" onclick="downloadPartition(-1)">Download</button>';
                    html += '<button class="replace-btn" onclick="replaceBootloader()">Replace</button>';
                    html += '<button class="replace-btn" onclick="clearBootloader()">Clear</button>';
                    html += '</div>';
                }

                contentDiv.innerHTML = html;

                // Find bootloader end (where 0xFF padding starts)
                let bootloaderEnd = image.endOffset || 0;
                // Scan forward from endOffset to find where 0xFF padding begins
                const scanSize = 256; // Check in 256-byte blocks
                for (let pos = bootloaderEnd; pos < maxBootloaderLength; pos += scanSize) {
                    let allFF = true;
                    const checkLen = Math.min(scanSize, maxBootloaderLength - pos);
                    for (let i = 0; i < checkLen; i++) {
                        if ((await parser.view.getUint8(pos + i)) !== 0xFF) {
                            allFF = false;
                            bootloaderEnd = pos + i + 1;
                            break;
                        }
                    }
                    if (allFF) {
                        // Found start of 0xFF region, bootloader ends here
                        break;
                    }
                }

                image.bootloaderStart = partition.offset;
                image.bootloaderEnd = bootloaderEnd;

                /* Auto-apply detected flash size in device mode */
                if (deviceMode && image.spiSizeName) {
                    /* Extract flash size from spiSizeName (e.g., "2 MiB", "4 MiB") */
                    const flashSizeMatch = image.spiSizeName.match(/(\d+)\s*([KMG]i?B)/i);
                    if (flashSizeMatch) {
                        let sizeBytes = parseInt(flashSizeMatch[1], 10);
                        const unit = flashSizeMatch[2].toUpperCase();

                        if (unit === 'KIB' || unit === 'KB') sizeBytes *= 1024;
                        else if (unit === 'MIB' || unit === 'MB') sizeBytes *= 1024 * 1024;
                        else if (unit === 'GIB' || unit === 'GB') sizeBytes *= 1024 * 1024 * 1024;

                        if (sizeBytes > 0 && sizeBytes !== deviceFlashSizeBytes) {
                            console.log(`Detected flash size from bootloader: ${image.spiSizeName} (${sizeBytes} bytes)`);
                            await applyDeviceFlashSize(sizeBytes);
                        }
                    }
                }

                return image;
            } catch (error) {
                console.error('Bootloader parsing error:', error);
                contentDiv.innerHTML = `<div class="error">Error parsing bootloader: ${error.message}</div>`;
                return null;
            }
        }

        async function displayPartitions() {
            const content = document.getElementById('partitionsContent');
            const partitions = parser.partitions;

            if (partitions.length === 0) {
                content.innerHTML = '<div class="error">No partitions found in this firmware image.</div>';
                return;
            }

            let html = '';
            if (partitionTableOffset !== null) {
                html += '<div class="info-grid" style="margin-bottom: 20px;">';
                html += `<div class="info-item"><label>Partition Table Offset:</label><span class="mono">0x${partitionTableOffset.toString(16).toUpperCase().padStart(4, '0')}</span></div>`;
                html += '</div>';
            }
            html += '<table><thead><tr>';
            html += '<th>#</th><th>Label</th><th>Type</th><th>Offset</th><th>Size</th><th>Actions</th>';
            html += '</tr></thead><tbody>';

            for (let idx = 0; idx < partitions.length; idx++) {
                const part = partitions[idx];
                const badgeClass = part.type === 0 ? 'app' : 'data';

                // Check if APP partition has valid magic
                let magicIndicator = '';
                if (part.type === 0) { // APP partition
                    const hasValidMagic = await parser.hasValidImageMagic(part);
                    if (hasValidMagic) {
                        magicIndicator = '<span style="color: #6ec589; font-size: 1.1em; margin-left: 5px;" title="Valid ESP32 image magic (0xE9)">âœ“</span>';
                    } else {
                        magicIndicator = '<span style="color: #e88888; font-size: 1.1em; margin-left: 5px;" title="Invalid or missing ESP32 image magic">âœ—</span>';
                    }
                }

                html += `<tr class="expandable" onclick="togglePartitionDetails(${idx})">`;
                html += `<td>${part.num}</td>`;
                html += `<td><strong>${part.label}${magicIndicator}</strong></td>`;
                html += `<td><span class="badge ${badgeClass}">${part.typeName}</span></td>`;
                html += `<td class="mono">0x${part.offset.toString(16).toUpperCase().padStart(6, '0')}</td>`;
                html += `<td>${formatBytes(part.length)}</td>`;
                html += `<td>
                    <button class="hex-btn" onclick="event.stopPropagation(); viewPartitionHex(${idx})">Hex View</button>
                    <button class="download-btn" onclick="event.stopPropagation(); downloadPartition(${idx})">Download</button>
                    <button class="replace-btn" onclick="event.stopPropagation(); replacePartition(${idx})">Replace</button>
                    <button class="replace-btn" onclick="event.stopPropagation(); clearPartition(${idx})">Clear</button>
                </td>`;
                html += '</tr>';

                // Details row
                html += `<tr class="details-row" id="details-${idx}">`;
                html += `<td colspan="6"><div class="details-content">`;
                html += `<div class="details-grid">`;
                html += `<div class="detail-item"><strong>Type Code:</strong> 0x${part.type.toString(16).toUpperCase()}</div>`;
                html += `<div class="detail-item"><strong>SubType Code:</strong> 0x${part.subType.toString(16).toUpperCase()}</div>`;
                html += `<div class="detail-item"><strong>Offset (decimal):</strong> ${part.offset}</div>`;
                html += `<div class="detail-item"><strong>Size (decimal):</strong> ${part.length} bytes</div>`;
                html += `<div class="detail-item"><strong>End Offset:</strong> 0x${(part.offset + part.length).toString(16).toUpperCase()}</div>`;

                // Add parse buttons for specific partition types
                if (part.subType === 0x02) { // NVS
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseNVSPartition(${idx})">Parse NVS</button></div>`;
                } else if (part.type === 0) { // APP
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseImagePartitionInline(${idx})">Parse Image</button></div>`;
                } else if (part.subType === 0x81) { // FAT
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseFATPartition(${idx})">Parse FAT</button></div>`;
                } else if (part.subType === 0x82) { // SPIFFS
                    html += `<div class="detail-item"><button class="btn" onclick="event.stopPropagation(); parseSPIFFSPartition(${idx})">Parse SPIFFS</button></div>`;
                }
                //html += `<div class="detail-item" style="grid-column: 1 / -1;"><strong>SHA-1:</strong> <span class="mono">${part.sha1 || 'n/a'}</span></div>`;

                html += `</div>`;

                // Add content area for inline parsed data
                html += `<div id="parsed-content-${idx}" style="margin-top: 15px;"></div>`;

                html += `</div></td></tr>`;
            }

            html += '</tbody></table>';
            content.innerHTML = html;
        }

        function replacePartition(idx) {
            replaceTargetPartition = idx;
            const input = document.getElementById('partitionFileInput');
            if (!input) {
                alert('Partition file input not found.');
                return;
            }
            input.value = '';
            input.click();
        }

        function replaceBootloader() {
            replaceTargetPartition = -1;
            const input = document.getElementById('partitionFileInput');
            if (!input) {
                alert('Partition file input not found.');
                return;
            }
            input.value = '';
            input.click();
        }

        async function clearBootloader() {
            if (!parser || (!parser.buffer && !parser.sparseImage)) {
                alert('No firmware file loaded.');
                return;
            }

            try {
                const start = 0;
                const length = 0x10000; /* 64KB bootloader max */
                const end = start + length;

                const totalSize = parser.sparseImage ? parser.sparseImage.size : parser.buffer.length;
                if (end > totalSize) {
                    alert('Bootloader region exceeds firmware image size.');
                    return;
                }

                /* Fill bootloader with 0xFF */
                parser.sparseImage.fill(0xFF, start, end);

                if (!deviceMode) {
                    /* Recompute bootloader in file mode */
                    await parseBootloader();
                }

                updateMemoryMap();
                alert('Bootloader cleared (filled with 0xFF).');
            } catch (err) {
                alert('Error clearing bootloader: ' + err.message);
            }
        }

        async function clearPartition(idx) {
            if (!parser || (!parser.buffer && !parser.sparseImage)) {
                alert('No firmware file loaded.');
                return;
            }

            const part = parser.partitions[idx];
            if (!part) {
                alert('Partition not found.');
                return;
            }

            try {
                const start = part.offset;
                const end = start + part.length;

                const totalSize = parser.sparseImage ? parser.sparseImage.size : parser.buffer.length;
                if (end > totalSize) {
                    alert('Partition range exceeds firmware image size.');
                    return;
                }

                // Fill partition with 0xFF
                parser.sparseImage.fill(0xFF, start, end);

                if (!deviceMode) {
                    part.sha1 = await parser.computePartitionSHA1(part);
                }

                await displayPartitions();

                const parsedContent = document.getElementById('parsed-content-' + idx);
                if (parsedContent) {
                    parsedContent.innerHTML = '';
                }

                const rawTab = document.querySelector('.tab.active');
                if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                    updateHexView();
                }

                updateMemoryMap();
            } catch (err) {
                alert('Error clearing partition: ' + err.message);
            }
        }

        function handlePartitionReplaceFile(file, idx) {
            if (!parser || (!parser.buffer && !parser.sparseImage)) {
                alert('No firmware file loaded.');
                return;
            }

            /* Handle bootloader (-1) and regular partitions */
            let part;
            if (idx === -1) {
                part = { label: 'bootloader', offset: 0, length: 0x10000 };
            } else {
                part = parser.partitions[idx];
                if (!part) {
                    alert('Partition not found.');
                    return;
                }
            }

            const reader = new FileReader();
            reader.onload = async function (e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    if (data.length > part.length) {
                        alert('Selected file is larger than the partition size.');
                        return;
                    }

                    const start = part.offset;
                    const end = start + part.length;

                    const totalSize = parser.sparseImage.size;
                    if (end > totalSize) {
                        alert('Partition range exceeds firmware image size.');
                        return;
                    }

                    parser.sparseImage.fill(0xFF, start, end);
                    parser.sparseImage.write(start, data);

                    if (!deviceMode && idx !== -1) {
                        part.sha1 = await parser.computePartitionSHA1(part);
                    }

                    /* Refresh bootloader or partitions */
                    if (idx === -1) {
                        await parseBootloader();
                    } else {
                        await displayPartitions();
                    }

                    const parsedContent = document.getElementById('parsed-content-' + idx);
                    if (parsedContent) {
                        parsedContent.innerHTML = '';
                    }

                    const rawTab = document.querySelector('.tab.active');
                    if (rawTab && rawTab.textContent.toLowerCase().includes('raw')) {
                        updateHexView();
                    }

                    updateMemoryMap();
                } catch (err) {
                    alert('Error replacing partition: ' + err.message);
                } finally {
                    replaceTargetPartition = null;
                    const inputEl = document.getElementById('partitionFileInput');
                    if (inputEl) {
                        inputEl.value = '';
                    }
                }
            };
            reader.onerror = function () {
                alert('Failed to read the selected file.');
            };
            reader.readAsArrayBuffer(file);
        }

        async function saveImage() {
            if (!parser || !parser.sparseImage) {
                alert('No firmware image loaded.');
                return;
            }

            showFetchOverlay('Preparing image download...');
            try {
                const data = await parser.sparseImage.slice_async(0, parser.sparseImage.size);
                const blob = new Blob([data], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'firmware_modified.bin';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                alert('Error preparing image: ' + error.message);
            } finally {
                hideFetchOverlay();
            }
        }

        async function writeToDevice() {
            if (!deviceFlasher || !deviceMode) {
                alert('No device connected.');
                return;
            }

            if (!parser || !parser.sparseImage) {
                alert('No firmware image loaded.');
                return;
            }

            // Check if there are any pending writes
            if (!parser.sparseImage.writeBuffer || parser.sparseImage.writeBuffer.length === 0) {
                alert('No changes to write. Please modify partitions first.');
                return;
            }

            const writeCount = parser.sparseImage.writeBuffer.length;
            const totalBytes = parser.sparseImage.writeBuffer.reduce((sum, seg) => sum + seg.data.length, 0);

            showWriteOverlay('Writing modified segments...');

            try {
                setDeviceStatus('Writing modified segments to device...', 'loading');
                updateWriteOverlayProgress(0, 0, totalBytes);
                await parser.sparseImage.flush();
            } catch (error) {
                console.error('Write error:', error);
                setDeviceStatus('Write failed: ' + error.message, 'error');
                alert('Error writing to device: ' + error.message);
            } finally {
                hideWriteOverlay();
            }

            await updateMemoryMap();
        }

        function togglePartitionDetails(idx) {
            const row = document.getElementById(`details-${idx}`);
            row.classList.toggle('visible');
        }

        function parseNVSPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            if (!contentDiv) {
                console.error(`Content div parsed-content-${idx} not found`);
                return;
            }

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing NVS data...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const pages = await parser.parseNVS(partition);

                    let html = '<div class="success" style="margin-bottom: 10px;">Found ' + pages.length + ' NVS pages <button class="nvs-add-btn" onclick="event.stopPropagation(); showNVSAddNamespaceDialog(' + idx + ')">âž• Add Namespace</button></div>';

                    const namespaceGroups = {};
                    const allNamespaces = new Set();
                    let totalItems = 0;

                    pages.forEach(page => {
                        page.items.forEach(item => {
                            if (item.nsIndex === 0) {
                                // Collect namespace definitions
                                if (item.namespace) {
                                    allNamespaces.add(item.namespace);
                                }
                                return;
                            }

                            // Skip blob index entries (show only the actual blob chunks with data)
                            if (item.isBlobIndex) {
                                return;
                            }

                            const ns = item.namespace || 'Unknown';
                            allNamespaces.add(ns);
                            if (!namespaceGroups[ns]) {
                                namespaceGroups[ns] = [];
                            }
                            namespaceGroups[ns].push(item);
                            totalItems++;
                        });
                    });

                    // Ensure all namespaces appear in namespaceGroups (even if empty)
                    allNamespaces.forEach(ns => {
                        if (!namespaceGroups[ns]) {
                            namespaceGroups[ns] = [];
                        }
                    });

                    if (allNamespaces.size === 0) {
                        html += '<div class="error">No namespaces found in this partition.</div>';
                    } else {
                        Object.keys(namespaceGroups).sort().forEach(ns => {
                            html += `<div class="nvs-namespace">Namespace: ${ns} (${namespaceGroups[ns].length} items)<button class="nvs-add-btn" onclick="event.stopPropagation(); showNVSAddDialog(${idx}, '${ns}')">âž• Add Item</button></div>`;
                            namespaceGroups[ns].forEach(item => {
                                const tooltip = `Offset: 0x${item.offset.toString(16).toUpperCase()} (${item.offset}), Size: ${item.entrySize} bytes`;
                                const crcBad = (item.headerCrcValid === false) || (item.dataCrcValid === false);
                                html += `<div class="nvs-item ${crcBad ? 'crc-bad' : ''}" title="${tooltip}" style="padding-right: 80px;">`;
                                html += `<button class="nvs-edit-btn" onclick="event.stopPropagation(); showNVSEditDialog(${idx}, '${ns}', '${item.key}', '${item.typeName}', ${JSON.stringify(item.value).replace(/"/g, '&quot;')})">âœï¸</button>`;
                                html += `<button class="nvs-delete-btn" onclick="event.stopPropagation(); deleteNVSItem(${idx}, '${ns}', '${item.key}')">âŒ</button>`;
                                html += `<strong>${item.key}</strong> <span class="badge">${item.typeName}</span><br>`;
                                html += `Value: <span class="mono">${formatNVSValue(item)}</span>`;

                                if (item.headerCrcCalc !== undefined || item.dataCrcCalc !== undefined) {
                                    const headerValid = item.headerCrcCalc === undefined || item.headerCrcValid;
                                    const dataValid = item.dataCrcCalc === undefined || item.dataCrcValid;
                                    const allValid = headerValid && dataValid;

                                    if (allValid) {
                                        /* Both CRCs OK - show compact version with hover info */
                                        let hoverText = '';
                                        if (item.headerCrcCalc !== undefined) {
                                            const storedHex = (item.crc32 >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.headerCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            hoverText += `Header CRC: stored 0x${storedHex}, calc 0x${calcHex}`;
                                        }
                                        if (item.dataCrcCalc !== undefined) {
                                            const storedHex = (item.dataCrcStored >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.dataCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            if (hoverText) hoverText += '\\n';
                                            hoverText += `Data CRC: stored 0x${storedHex}, calc 0x${calcHex}`;
                                        }
                                        html += `<div class="crc-info" title="${hoverText}">CRCs: <span class="ok">OK</span> <span style="color: #9a9a9a;">â„¹ï¸</span></div>`;
                                    } else {
                                        /* At least one CRC failed - show full details */
                                        if (item.headerCrcCalc !== undefined) {
                                            const headerStatus = item.headerCrcValid ? '<span class="ok">OK</span>' : '<span class="bad">BAD</span>';
                                            const storedHex = (item.crc32 >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.headerCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            html += `<div class="crc-info">Header CRC: ${headerStatus} (stored 0x${storedHex}, calc 0x${calcHex})</div>`;
                                        }
                                        if (item.dataCrcCalc !== undefined) {
                                            const dataStatus = item.dataCrcValid ? '<span class="ok">OK</span>' : '<span class="bad">BAD</span>';
                                            const storedHex = (item.dataCrcStored >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            const calcHex = (item.dataCrcCalc >>> 0).toString(16).toUpperCase().padStart(8, '0');
                                            html += `<div class="crc-info">Data CRC: ${dataStatus} (stored 0x${storedHex}, calc 0x${calcHex})</div>`;
                                        }
                                    }
                                }
                                html += `</div>`;
                            });
                        });
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('NVS parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing NVS: ${error.message}</div>`;
                }
            }, 100);
        }

        function formatNVSValue(item) {
            if (item.value === null) return 'null';
            if (typeof item.value === 'object') return JSON.stringify(item.value);
            if (item.typeName === 'String') return `"${item.value}"`;

            // For Blob chunks, show chunk info and data
            if (item.typeName === 'Blob' && item.chunkIndex !== undefined && item.chunkIndex !== 0xFF) {
                const chunkInfo = `<span style="color: #888;">[Chunk ${item.chunkIndex}]</span> `;

                if (item.rawValue) {
                    let hexLines = [];
                    let asciiLines = [];
                    const width = 32;

                    for (let i = 0; i < item.rawValue.length; i += width) {
                        const chunk = item.rawValue.slice(i, i + width);
                        const hexLine = Array.from(chunk)
                            .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                            .join(' ');
                        hexLines.push(hexLine);

                        let asciiLine = '';
                        for (let j = 0; j < chunk.length; j++) {
                            const byte = chunk[j];
                            asciiLine += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                        }
                        asciiLines.push(asciiLine);
                    }

                    return chunkInfo + `Hex:<br>${hexLines.join('<br>')}<br><span style="color: #d4a574;">ASCII:<br>${asciiLines.join('<br>')}</span>`;
                }
                return chunkInfo + item.value;
            }

            // For regular Blobs with raw data
            if (item.typeName === 'Blob' && item.rawValue) {
                let hexLines = [];
                let asciiLines = [];

                for (let i = 0; i < item.rawValue.length; i += 16) {
                    const chunk = item.rawValue.slice(i, i + 16);
                    const hexLine = Array.from(chunk)
                        .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                        .join(' ');
                    hexLines.push(hexLine);

                    let asciiLine = '';
                    for (let j = 0; j < chunk.length; j++) {
                        const byte = chunk[j];
                        asciiLine += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                    }
                    asciiLines.push(asciiLine);
                }

                return `Hex:<br>${hexLines.join('<br>')}<br><span style="color: #d4a574;">ASCII:<br>${asciiLines.join('<br>')}</span>`;
            }

            return item.value;
        }

        let currentFATInfo = null;
        let currentFATPartition = null;
        let currentSPIFFSInfo = null;
        let currentSPIFFSPartition = null;

        function parseSPIFFSPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing SPIFFS filesystem...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const spiffsInfo = await parser.parseSPIFFS(partition);

                    // Store for file downloads
                    currentSPIFFSInfo = spiffsInfo;
                    currentSPIFFSPartition = partition;

                    let html = '';
                    
                    if (!spiffsInfo.valid) {
                        html += '<div class="error" style="margin-bottom: 10px;">âš ï¸ SPIFFS header not found. The partition may be empty, corrupted, or using a different filesystem.</div>';
                    } else {
                        html += '<div class="success" style="margin-bottom: 10px;">SPIFFS filesystem detected</div>';
                    }

                    // Filesystem info
                    html += '<h4 style="margin-top: 15px;">SPIFFS Information</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Valid Header:</label><span>${spiffsInfo.valid ? 'Yes' : 'No (estimated)'}</span></div>`;
                    if (spiffsInfo.magic) {
                        html += `<div class="info-item"><label>Magic:</label><span class="mono">0x${spiffsInfo.magic.toString(16).toUpperCase()}</span></div>`;
                    }
                    html += `<div class="info-item"><label>Block Size:</label><span>${spiffsInfo.blockSize} bytes (0x${spiffsInfo.blockSize.toString(16).toUpperCase()})</span></div>`;
                    html += `<div class="info-item"><label>Page Size:</label><span>${spiffsInfo.pageSize} bytes</span></div>`;
                    html += `<div class="info-item"><label>Total Size:</label><span>${formatBytes(spiffsInfo.totalSize)}</span></div>`;
                    html += `<div class="info-item"><label>Files Found:</label><span>${spiffsInfo.filesCount}</span></div>`;
                    html += '</div>';

                    // Files list with grouping: active vs deleted/old versions
                    if (spiffsInfo.files.length > 0) {
                        const activeFiles = spiffsInfo.files.filter(f => !f.deleted);
                        const deletedFiles = spiffsInfo.files.filter(f => f.deleted);

                        // Active files
                        html += `<h4 style="margin-top: 15px;">Files (${activeFiles.length} active${deletedFiles.length ? `, ${deletedFiles.length} deleted` : ''})</h4>`;
                        if (activeFiles.length > 0) {
                            html += '<table style="margin-top: 10px;"><thead><tr>';
                            html += '<th>Name</th><th>Object ID</th><th>Size</th><th>Block</th>';
                            html += '</tr></thead><tbody>';

                            activeFiles.forEach((file, fileIdx) => {
                                const fileId = `spiffsFile_${idx}_act_${fileIdx}`;
                                window[fileId] = file;
                                const clickable = file.size > 0;
                                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                                html += `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadSPIFFSFile('${fileId}')"` : ''}>`;
                                html += `<td><strong>${escapeHtml(file.name)}</strong></td>`;
                                html += `<td class="mono">0x${file.objId.toString(16).toUpperCase().padStart(4, '0')}</td>`;
                                html += `<td>${file.size > 0 ? formatBytes(file.size) : 'Unknown'}</td>`;
                                html += `<td>${file.blockIdx}</td>`;
                                html += '</tr>';
                            });

                            html += '</tbody></table>';
                        } else {
                            html += '<div style="margin-top: 10px; color: #888;">No active files found</div>';
                        }

                        // Deleted / old versions (collapsed group)
                        html += `<div style="margin-top: 18px;">
                                    <div class="expandable" style="padding:10px; border:1px solid #444; border-radius:6px; background:#2a2a2a;" onclick="(function(){
                                        const el=document.getElementById('spiffsDeletedGroup-${idx}');
                                        const ic=document.getElementById('spiffsDeletedToggle-${idx}');
                                        if(!el||!ic) return; 
                                        const vis=el.style.display!=='none';
                                        el.style.display= vis ? 'none' : 'block';
                                        ic.textContent = vis ? 'â–¶' : 'â–¼';
                                    })()">
                                        <span id="spiffsDeletedToggle-${idx}">â–¶</span>
                                        <strong style="margin-left:6px;">Deleted / old versions</strong>
                                        <span style="color:#aaa; margin-left:8px;">(${deletedFiles.length})</span>
                                    </div>
                                    <div id="spiffsDeletedGroup-${idx}" style="display:none; margin-top:8px;">
                                `;
                        if (deletedFiles.length > 0) {
                            html += '<table style="margin-top: 6px;"><thead><tr>';
                            html += '<th>Name</th><th>Object ID</th><th>Size</th><th>Block</th>';
                            html += '</tr></thead><tbody>';

                            deletedFiles.forEach((file, fileIdx) => {
                                const fileId = `spiffsFile_${idx}_del_${fileIdx}`;
                                window[fileId] = file;
                                const clickable = file.size > 0;
                                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                                html += `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadSPIFFSFile('${fileId}')"` : ''}>`;
                                html += `<td><strong>${escapeHtml(file.name)}</strong></td>`;
                                html += `<td class="mono">0x${file.objId.toString(16).toUpperCase().padStart(4, '0')}</td>`;
                                html += `<td>${file.size > 0 ? formatBytes(file.size) : (file.size === 0 ? '0' : 'Unknown')}</td>`;
                                html += `<td>${file.blockIdx}</td>`;
                                html += '</tr>';
                            });

                            html += '</tbody></table>';
                        } else {
                            html += '<div style="margin-top: 8px; color: #888;">No deleted entries</div>';
                        }
                        html += '</div></div>';
                    } else {
                        html += '<div style="margin-top: 15px; color: #888;">No files found. The filesystem may be empty or the partition is not SPIFFS.</div>';
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('SPIFFS parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing SPIFFS: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadSPIFFSFile(fileId) {
            const file = window[fileId];
            if (!file || !currentSPIFFSInfo || !currentSPIFFSPartition) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'spiffs-loading-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Loading ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const fileData = await parser.readSPIFFSFile(currentSPIFFSPartition, file, currentSPIFFSInfo);
                const blob = new Blob([fileData], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('spiffs-loading-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        function parseFATPartition(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading indicator
            contentDiv.innerHTML = '<div class="loading">â³ Parsing FAT filesystem...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const fatInfo = await parser.parseFATFilesystem(partition);

                    if (fatInfo.error) {
                        contentDiv.innerHTML = `<div class="error">${fatInfo.error}</div>`;
                        return;
                    }

                    // Store for file downloads
                    currentFATInfo = fatInfo;
                    currentFATPartition = partition;

                    let html = '<div class="success" style="margin-bottom: 10px;">FAT filesystem parsed successfully</div>';

                    // Filesystem info
                    html += '<h4 style="margin-top: 15px;">Filesystem Information</h4>';
                    html += '<div class="info-grid">';
                    html += `<div class="info-item"><label>Type:</label><span>${fatInfo.fatType}</span></div>`;
                    html += `<div class="info-item"><label>Volume Label:</label><span>${fatInfo.volumeLabel}</span></div>`;
                    html += `<div class="info-item"><label>Bytes/Sector:</label><span>${fatInfo.bytesPerSector}</span></div>`;
                    html += `<div class="info-item"><label>Sectors/Cluster:</label><span>${fatInfo.sectorsPerCluster}</span></div>`;
                    html += `<div class="info-item"><label>Total Sectors:</label><span>${fatInfo.totalSectors}</span></div>`;
                    html += `<div class="info-item"><label>Total Clusters:</label><span>${fatInfo.totalClusters}</span></div>`;
                    html += '</div>';

                    // Wear leveling info
                    if (fatInfo.wearLeveling && fatInfo.wearLeveling.wlState) {
                        const wl = fatInfo.wearLeveling.wlState;
                        html += '<h4 style="margin-top: 15px;">Wear Leveling</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Move Count:</label><span>${wl.moveCount}</span></div>`;
                        html += `<div class="info-item"><label>Access Count:</label><span>${wl.accessCount}</span></div>`;
                        html += `<div class="info-item"><label>Max Count:</label><span>${wl.maxCount}</span></div>`;
                        html += `<div class="info-item"><label>Block Size:</label><span>0x${wl.blockSize.toString(16).toUpperCase()}</span></div>`;
                        html += `<div class="info-item"><label>Version:</label><span>${wl.version}</span></div>`;
                        html += `<div class="info-item"><label>Device ID:</label><span>0x${wl.deviceId.toString(16).toUpperCase()}</span></div>`;
                        html += '</div>';
                    }

                    // Files list
                    html += '<h4 style="margin-top: 15px;">Files (' + countTotalFiles(fatInfo.files) + ' total entries)</h4>';
                    if (fatInfo.files.length > 0) {
                        html += '<table style="margin-top: 10px;"><thead><tr>';
                        html += '<th>Path</th><th>Size</th><th>Attributes</th><th>Date</th><th>Time</th><th>Cluster</th>';
                        html += '</tr></thead><tbody>';

                        renderFATFiles(fatInfo.files, 0).forEach(row => {
                            html += row;
                        });

                        html += '</tbody></table>';
                    } else {
                        html += '<div style="margin-top: 10px; color: #888;">No files found</div>';
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('FAT parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing FAT: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadFATFile(fileId) {
            const file = window[fileId];
            if (!file || !currentFATInfo || !currentFATPartition) {
                alert('File data not available');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'fat-loading-indicator';
            loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px 40px; border-radius: 8px; z-index: 10000; font-size: 16px;';
            loadingDiv.textContent = `Loading ${file.name}...`;
            document.body.appendChild(loadingDiv);

            try {
                const blob = await parser.extractFATFile(currentFATPartition, currentFATInfo, file);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = file.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error downloading file: ' + error.message);
            } finally {
                // Remove loading indicator
                const indicator = document.getElementById('fat-loading-indicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            }
        }

        function countTotalFiles(files) {
            let count = files.length;
            files.forEach(file => {
                if (file.children && file.children.length > 0) {
                    count += countTotalFiles(file.children);
                }
            });
            return count;
        }

        function renderFATFiles(files, depth) {
            const rows = [];
            const indent = '&nbsp;&nbsp;&nbsp;&nbsp;'.repeat(depth);

            files.forEach((file, fileIdx) => {
                const fileId = `fat-file-${depth}-${fileIdx}-${file.cluster}`;
                const clickable = !file.isDirectory && file.size > 0;
                const cursorStyle = clickable ? 'cursor: pointer;' : '';
                const hoverClass = clickable ? 'class="fat-file-row"' : '';

                let row = `<tr ${hoverClass} style="${cursorStyle}" ${clickable ? `onclick="downloadFATFile('${fileId}')"` : ''}>`;

                // Path column with indentation
                const icon = file.isDirectory ? 'ðŸ“' : 'ðŸ“„';
                row += `<td>${indent}${icon} <strong>${file.path || file.name}</strong></td>`;

                // Size (show - for directories)
                row += `<td>${file.isDirectory ? '-' : formatBytes(file.size)}</td>`;

                // Attributes
                row += `<td>${file.attributes.join(', ') || 'None'}</td>`;

                // Date & Time
                row += `<td class="mono">${file.date}</td>`;
                row += `<td class="mono">${file.time}</td>`;

                // Store file data for download
                if (clickable) {
                    window[fileId] = file;
                }

                // Cluster
                row += `<td class="mono">0x${file.cluster.toString(16).toUpperCase()}</td>`;
                row += '</tr>';

                rows.push(row);

                // Add children if directory
                if (file.children && file.children.length > 0) {
                    rows.push(...renderFATFiles(file.children, depth + 1));
                }
            });

            return rows;
        }

        function parseImagePartitionInline(idx) {
            const partition = parser.partitions[idx];
            const contentDiv = document.getElementById(`parsed-content-${idx}`);

            // Show loading
            contentDiv.innerHTML = '<div class="loading">â³ Parsing firmware image...</div>';

            // Use setTimeout to allow UI to update
            setTimeout(async () => {
                try {
                    const image = await parser.parseImage(partition.offset, partition.length);

                    // Validate SHA256 (appended) and compute region/full hashes
                    let sha256Validation = null;
                    let sha256Calculated = null;
                    let sha256RegionCalc = null;

                    const calcSliceEnd = Math.min(partition.offset + partition.length, parser.buffer.length);
                    if (calcSliceEnd > partition.offset) {
                        const calcData = parser.buffer.slice(partition.offset, calcSliceEnd);
                        const calcHash = await ESP32Parser.calculateSHA256(calcData);
                        sha256Calculated = ESP32Parser.bytesToHex(calcHash);
                    }

                    if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined && image.sha256DataEnd > image.sha256DataStart) {
                        console.log(`Image SHA256 region: start=0x${image.sha256DataStart.toString(16)}, end=0x${image.sha256DataEnd.toString(16)}, length=${image.sha256DataEnd - image.sha256DataStart}`);
                        const regionData = parser.buffer.slice(image.sha256DataStart, image.sha256DataEnd);
                        const regionHash = await ESP32Parser.calculateSHA256(regionData);
                        sha256RegionCalc = ESP32Parser.bytesToHex(regionHash);
                    }

                    if (image.sha256) {
                        sha256Validation = await parser.validateImageSHA256(image);
                        // If validation didn't compute, reuse region calc
                        if (sha256Validation && !sha256Validation.calculated && sha256RegionCalc) {
                            sha256Validation.calculated = sha256RegionCalc;
                        }
                    }

                    let html = '';

                    if (image.error) {
                        html = `<div class="error">${image.error}</div>`;
                    } else {
                        html = '<div class="success">Firmware image parsed successfully</div>';

                        html += '<h4 style="margin-top: 15px;">Basic Information</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Magic:</label><span class="mono">0x${image.magic.toString(16).toUpperCase()}</span></div>`;
                        html += `<div class="info-item"><label>Segment Count:</label><span>${image.segmentCount}</span></div>`;
                        html += `<div class="info-item"><label>Entry Address:</label><span class="mono">0x${image.entryAddr.toString(16).toUpperCase().padStart(8, '0')}</span></div>`;
                        html += `<div class="info-item"><label>Chip:</label><span>${image.chipName} (0x${image.chipId.toString(16).toUpperCase().padStart(4, '0')})</span></div>`;
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Flash Configuration</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>SPI Mode:</label><span>${image.spiModeName} (${image.spiMode})</span></div>`;
                        html += `<div class="info-item"><label>SPI Speed:</label><span>${image.spiSpeedName}</span></div>`;
                        html += `<div class="info-item"><label>Flash Size:</label><span>${image.spiSizeName}</span></div>`;
                        html += `<div class="info-item"><label>WP Pin:</label><span>${image.wpPinDisabled ? 'Disabled (0xEE)' : '0x' + image.wpPin.toString(16).toUpperCase()}</span></div>`;
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Chip Revision</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Min Chip Rev:</label><span>v${image.minChipRevMajor}.${image.minChipRevMinor} (${image.minChipRevFull})</span></div>`;
                        html += `<div class="info-item"><label>Max Chip Rev:</label><span>v${image.maxChipRevMajor}.${image.maxChipRevMinor} (${image.maxChipRevFull})</span></div>`;
                        html += `<div class="info-item"><label>Legacy Min Rev:</label><span>${image.minChipRev}</span></div>`;
                        html += '</div>';

                        // App Description (if found)
                        if (image.appDesc && image.appDesc.found) {
                            html += '<h4 style="margin-top: 15px;">Application Description</h4>';
                            html += '<div class="info-grid">';
                            if (image.appDesc.projectName) {
                                html += `<div class="info-item"><label>Project Name:</label><span>${image.appDesc.projectName}</span></div>`;
                            }
                            if (image.appDesc.version) {
                                html += `<div class="info-item"><label>Version:</label><span>${image.appDesc.version}</span></div>`;
                            }
                            if (image.appDesc.idfVer) {
                                html += `<div class="info-item"><label>ESP-IDF Version:</label><span>${image.appDesc.idfVer}</span></div>`;
                            }
                            html += `<div class="info-item"><label>Secure Version:</label><span>${image.appDesc.secureVersion}</span></div>`;
                            if (image.appDesc.date && image.appDesc.time) {
                                html += `<div class="info-item"><label>Build Date/Time:</label><span>${image.appDesc.date} ${image.appDesc.time}</span></div>`;
                            }
                            if (image.appDesc.appElfSha256) {
                                html += `<div class="info-item" style="grid-column: 1 / -1;"><label>App ELF SHA256:</label><span class="mono" title="Reference only - ELF file not available for validation">${image.appDesc.appElfSha256} <span style="color: #9a9a9a;">â„¹ï¸</span></span></div>`;
                            }
                            html += '</div>';
                        }

                        html += '<h4 style="margin-top: 15px;">Validation</h4>';
                        html += '<div class="info-grid">';
                        html += `<div class="info-item"><label>Checksum:</label><span class="mono">0x${(image.checksum || 0).toString(16).toUpperCase().padStart(2, '0')}</span></div>`;
                        html += `<div class="info-item"><label>Hash Appended:</label><span>${image.hasHash ? 'Yes' : 'No'}</span></div>`;
                        if (image.sha256) {
                            const validIcon = sha256Validation && sha256Validation.valid ?
                                '<span style="color: #6ec589; font-size: 1.2em;" title="Hash verified over header..checksum region">âœ“</span>' :
                                sha256Validation && sha256Validation.valid === false ?
                                    '<span style="color: #e88888; font-size: 1.2em;" title="' + sha256Validation.reason + '">âœ—</span>' :
                                    '<span style="color: #9a9a9a; font-size: 1.2em;" title="Validating...">â³</span>';
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Image SHA256 (appended):</label><span class="mono">${image.sha256} ${validIcon}</span></div>`;
                        }
                        if (sha256RegionCalc) {
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Region SHA256 (header..checksum):</label><span class="mono">${sha256RegionCalc}</span></div>`;
                        }
                        if (image.sha256DataStart !== undefined && image.sha256DataEnd !== undefined) {
                            const regionLen = image.sha256DataEnd - image.sha256DataStart;
                            html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Hash region:</label><span class="mono">0x${image.sha256DataStart.toString(16).toUpperCase()} - 0x${image.sha256DataEnd.toString(16).toUpperCase()} (${regionLen} bytes)</span></div>`;
                        }
                        if (sha256Calculated) {
                            if (image.sha256 && sha256Validation && sha256Validation.valid === false && sha256Validation.calculated) {
                                html += `<div class="info-item" style="grid-column: 1 / -1;"><label>Expected vs Calc (region):</label><span class="mono" style="color: #e88888;">${sha256Validation.expected} â‰  ${sha256Validation.calculated}</span></div>`;
                            }
                        }
                        html += '</div>';

                        html += '<h4 style="margin-top: 15px;">Segments</h4>';
                        html += '<table><thead><tr><th>#</th><th>Load Address</th><th>Length</th><th>Offset</th></tr></thead><tbody>';
                        image.segmentList.forEach((seg, sidx) => {
                            html += '<tr>';
                            html += `<td>${sidx}</td>`;
                            html += `<td class="mono">0x${seg.loadAddress.toString(16).toUpperCase().padStart(8, '0')}</td>`;
                            html += `<td>${formatBytes(seg.length)}</td>`;
                            html += `<td class="mono">0x${seg.offset.toString(16).toUpperCase()}</td>`;
                            html += '</tr>';
                        });
                        html += '</tbody></table>';
                    }

                    contentDiv.innerHTML = html;
                } catch (error) {
                    console.error('Image parsing error:', error);
                    contentDiv.innerHTML = `<div class="error">Error parsing image: ${error.message}</div>`;
                }
            }, 100);
        }

        async function downloadPartition(idx) {
            /* Handle bootloader (-1) and regular partitions */
            let partition;
            if (idx === -1) {
                partition = { label: 'bootloader', offset: bootloaderInfo.bootloaderStart, length: bootloaderInfo.bootloaderEnd - bootloaderInfo.bootloaderStart };
            } else {
                partition = parser.partitions[idx];
            }

            setFetchOverlayReason(`Download ${partition.label}`);
            showFetchOverlay(`Downloading ${partition.label}...`);
            try {
                const blob = await parser.exportPartitionData(partition);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${partition.label}_0x${partition.offset.toString(16)}.bin`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Partition download error:', error);
                alert('Error downloading partition: ' + error.message);
            } finally {
                hideFetchOverlay();
                setFetchOverlayReason('');
            }
        }

        async function viewPartitionHex(idx) {
            /* Handle bootloader (-1) and regular partitions */
            let partition;
            if (idx === -1) {
                partition = { label: 'bootloader', offset: 0, length: 0x10000 };
            } else {
                partition = parser.partitions[idx];
            }
            document.getElementById('hexOffset').value = '0x' + partition.offset.toString(16).toUpperCase();
            document.getElementById('hexLength').value = '0x' + Math.min(partition.length, 0x1000).toString(16).toUpperCase();
            switchTab('raw');
            updateHexView();
        }

        async function updateHexView() {
            const offsetStr = document.getElementById('hexOffset').value.trim();
            const lengthStr = document.getElementById('hexLength').value.trim();
            const rawContent = document.getElementById('rawContent');

            if (!parser) {
                rawContent.innerHTML = '<div class="error">No firmware loaded</div>';
                return;
            }

            // Show loading indicator
            rawContent.innerHTML = '<div style="text-align: center; padding: 40px; color: #888;">Loading hex view...</div>';

            try {
                const offset = parseInt(offsetStr, 16);
                const length = parseInt(lengthStr, 16);

                if (isNaN(offset) || isNaN(length)) {
                    rawContent.innerHTML = '<div class="error">Invalid offset or length. Use hex format (e.g., 0x1000)</div>';
                    return;
                }

                const totalLen = (parser && parser.buffer && typeof parser.buffer.length === 'number')
                    ? parser.buffer.length
                    : (parser.view && parser.view.buffer && parser.view.buffer.byteLength) ? parser.view.buffer.byteLength : 0;

                if (offset < 0 || offset >= totalLen) {
                    rawContent.innerHTML = '<div class="error">Offset out of range</div>';
                    return;
                }

                const actualLength = Math.min(length, totalLen - offset);
                if (actualLength > 0x10000) {
                    rawContent.innerHTML = '<div class="error">Length too large. Maximum is 0x10000 (64KB)</div>';
                    return;
                }

                const hexView = await generateHexView(offset, actualLength);
                rawContent.innerHTML = hexView;
            } catch (error) {
                rawContent.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }

        async function generateHexView(offset, length) {
            let bytes;
            if (parser && parser.sparseImage && typeof parser.sparseImage.subarray_async === 'function') {
                bytes = await parser.sparseImage.subarray_async(offset, offset + length);
            } else if (parser && parser.buffer && typeof parser.buffer.subarray === 'function') {
                bytes = parser.buffer.subarray(offset, offset + length);
            } else {
                bytes = new Uint8Array(parser.view.buffer, offset, length);
            }
            const widthInput = document.getElementById('hexWidth');
            const bytesPerLine = widthInput ? parseInt(widthInput.value) || 16 : 16;

            let html = '<div class="hex-viewer">';

            for (let i = 0; i < bytes.length; i += bytesPerLine) {
                const lineOffset = offset + i;
                const lineBytes = bytes.slice(i, Math.min(i + bytesPerLine, bytes.length));

                html += '<div>';

                // Offset (colored)
                html += `<span class="hex-offset">${lineOffset.toString(16).toUpperCase().padStart(8, '0')}</span>  `;

                // Hex bytes (colored)
                let hexPart = '';
                for (let j = 0; j < bytesPerLine; j++) {
                    if (j < lineBytes.length) {
                        const byte = lineBytes[j];
                        hexPart += byte.toString(16).toUpperCase().padStart(2, '0') + ' ';
                    } else {
                        hexPart += '   ';
                    }

                    if (j === Math.floor(bytesPerLine / 2) - 1) {
                        hexPart += ' ';
                    }
                }
                html += `<span class="hex-bytes">${hexPart}</span>`;

                // Add spacing before ASCII
                html += '   ';

                // ASCII representation (colored)
                let asciiPart = '';
                for (let j = 0; j < lineBytes.length; j++) {
                    const byte = lineBytes[j];
                    asciiPart += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                }
                html += `<span class="hex-ascii">${asciiPart}</span>`;

                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        function switchTab(tabName, event) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            if (event?.target) {
                event.target.classList.add('active');
            } else {
                // Find and activate by tab name if no event
                document.querySelectorAll('.tab').forEach(tab => {
                    if (tab.textContent.toLowerCase().includes(tabName)) {
                        tab.classList.add('active');
                    }
                });
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        function showError(message) {
            const content = document.getElementById('partitionsContent');
            content.innerHTML = `<div class="error">${message}</div>`;
        }

        async function deleteNVSItem(partitionIdx, namespace, key) {
            if (!parser || !parser.sparseImage) {
                alert('No firmware loaded.');
                return;
            }

            const partition = parser.partitions[partitionIdx];
            if (!partition) {
                alert('Partition not found.');
                return;
            }

            try {
                await parser.deleteNVSItem(partition, namespace, key);

                // Refresh the NVS display
                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Deleted NVS item: ${namespace}.${key}`, 'success');
            } catch (error) {
                alert('Error deleting NVS item: ' + error.message);
            }
        }

        let currentNVSAddPartition = null;
        let currentNVSAddNamespace = null;

        function showNVSAddDialog(partitionIdx, namespace) {
            currentNVSAddPartition = partitionIdx;
            currentNVSAddNamespace = namespace;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            popup.innerHTML = `
                <h3>Add NVS Item to ${namespace}</h3>
                <label for="nvs-add-key">Key:</label>
                <input type="text" id="nvs-add-key" maxlength="15" placeholder="Key name (max 15 chars)">
                
                <label for="nvs-add-type">Type:</label>
                <select id="nvs-add-type" onchange="updateNVSAddValueInput()">
                    <option value="U8">U8 (Unsigned 8-bit)</option>
                    <option value="U16">U16 (Unsigned 16-bit)</option>
                    <option value="U32">U32 (Unsigned 32-bit)</option>
                    <option value="U64">U64 (Unsigned 64-bit)</option>
                    <option value="I8">I8 (Signed 8-bit)</option>
                    <option value="I16">I16 (Signed 16-bit)</option>
                    <option value="I32">I32 (Signed 32-bit)</option>
                    <option value="I64">I64 (Signed 64-bit)</option>
                    <option value="String">String</option>
                    <option value="Blob">Blob (Hex)</option>
                </select>
                
                <label for="nvs-add-value">Value:</label>
                <input type="text" id="nvs-add-value" placeholder="Enter value">
                <div id="nvs-add-value-hint" style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a number (0-255)</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSAddDialog()" style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Add</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Initialize value input hint
            setTimeout(() => {
                updateNVSAddValueInput();
                document.getElementById('nvs-add-key').focus();
            }, 100);
        }

        function showNVSAddNamespaceDialog(partitionIdx) {
            currentNVSAddPartition = partitionIdx;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            popup.innerHTML = `
                <h3>Add New Namespace</h3>
                <label for="nvs-namespace-name">Namespace Name:</label>
                <input type="text" id="nvs-namespace-name" maxlength="15" placeholder="Namespace name (max 15 chars)">
                <div style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a unique namespace name</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSAddNamespaceDialog()" style="background: linear-gradient(135deg, #4d8f52 0%, #2e7d32 100%);">Create</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            setTimeout(() => {
                document.getElementById('nvs-namespace-name').focus();
            }, 100);
        }

        function showNVSEditDialog(partitionIdx, namespace, key, type, value) {
            currentNVSAddPartition = partitionIdx;
            currentNVSAddNamespace = namespace;
            window.currentNVSEditKey = key;

            const overlay = document.createElement('div');
            overlay.className = 'nvs-popup-overlay';
            overlay.onclick = closeNVSAddDialog;

            const popup = document.createElement('div');
            popup.className = 'nvs-popup';
            popup.onclick = (e) => e.stopPropagation();

            // Format value for display in input
            let displayValue = value;
            if (type === 'String') {
                displayValue = value.replace(/^"|"$/g, '');
            } else if (type === 'Blob') {
                // Extract hex from formatted blob value
                if (typeof value === 'string') {
                    const hexMatch = value.match(/Hex: ([0-9A-F ]+)/i);
                    if (hexMatch) {
                        displayValue = hexMatch[1];
                    }
                }
            }

            popup.innerHTML = `
                <h3>Edit NVS Item: ${key}</h3>
                <label>Key: <strong>${key}</strong> (read-only)</label>
                
                <label for="nvs-add-type">Type:</label>
                <select id="nvs-add-type" onchange="updateNVSAddValueInput()">
                    <option value="U8" ${type === 'U8' ? 'selected' : ''}>U8 (Unsigned 8-bit)</option>
                    <option value="U16" ${type === 'U16' ? 'selected' : ''}>U16 (Unsigned 16-bit)</option>
                    <option value="U32" ${type === 'U32' ? 'selected' : ''}>U32 (Unsigned 32-bit)</option>
                    <option value="U64" ${type === 'U64' ? 'selected' : ''}>U64 (Unsigned 64-bit)</option>
                    <option value="I8" ${type === 'I8' ? 'selected' : ''}>I8 (Signed 8-bit)</option>
                    <option value="I16" ${type === 'I16' ? 'selected' : ''}>I16 (Signed 16-bit)</option>
                    <option value="I32" ${type === 'I32' ? 'selected' : ''}>I32 (Signed 32-bit)</option>
                    <option value="I64" ${type === 'I64' ? 'selected' : ''}>I64 (Signed 64-bit)</option>
                    <option value="String" ${type === 'String' ? 'selected' : ''}>String</option>
                    <option value="Blob" ${type === 'Blob' ? 'selected' : ''}>Blob (Hex)</option>
                </select>
                
                <label for="nvs-add-value">Value:</label>
                <input type="text" id="nvs-add-value" placeholder="Enter value" value="${displayValue}">
                <div id="nvs-add-value-hint" style="font-size: 0.85em; color: #888; margin-top: 5px;">Enter a number (0-255)</div>
                
                <div class="nvs-popup-buttons">
                    <button class="btn" onclick="closeNVSAddDialog()">Cancel</button>
                    <button class="btn" onclick="submitNVSEditDialog()" style="background: linear-gradient(135deg, #d49f37 0%, #b58f30 100%);">Save</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Initialize value input hint
            setTimeout(() => {
                updateNVSAddValueInput();
                document.getElementById('nvs-add-value').focus();
                document.getElementById('nvs-add-value').select();
            }, 100);
        }

        function updateNVSAddValueInput() {
            const typeSelect = document.getElementById('nvs-add-type');
            const valueInput = document.getElementById('nvs-add-value');
            const hint = document.getElementById('nvs-add-value-hint');

            if (!typeSelect || !valueInput || !hint) return;

            const type = typeSelect.value;

            switch (type) {
                case 'U8':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-255)';
                    hint.textContent = 'Range: 0 to 255';
                    break;
                case 'U16':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-65535)';
                    hint.textContent = 'Range: 0 to 65535';
                    break;
                case 'U32':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (0-4294967295)';
                    hint.textContent = 'Range: 0 to 4294967295';
                    break;
                case 'U64':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter number (0-18446744073709551615)';
                    hint.textContent = 'Range: 0 to 18446744073709551615';
                    break;
                case 'I8':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-128 to 127)';
                    hint.textContent = 'Range: -128 to 127';
                    break;
                case 'I16':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-32768 to 32767)';
                    hint.textContent = 'Range: -32768 to 32767';
                    break;
                case 'I32':
                    valueInput.type = 'number';
                    valueInput.placeholder = 'Enter number (-2147483648 to 2147483647)';
                    hint.textContent = 'Range: -2147483648 to 2147483647';
                    break;
                case 'I64':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter number (-9223372036854775808 to 9223372036854775807)';
                    hint.textContent = 'Range: -9223372036854775808 to 9223372036854775807';
                    break;
                case 'String':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter string value';
                    hint.textContent = 'Enter any text (max 64 bytes)';
                    break;
                case 'Blob':
                    valueInput.type = 'text';
                    valueInput.placeholder = 'Enter hex bytes (e.g., 01 02 03 FF)';
                    hint.textContent = 'Enter hex bytes separated by spaces';
                    break;
            }
        }

        function closeNVSAddDialog() {
            const overlay = document.querySelector('.nvs-popup-overlay');
            if (overlay) {
                document.body.removeChild(overlay);
            }
            currentNVSAddPartition = null;
            currentNVSAddNamespace = null;
        }

        async function submitNVSAddDialog() {
            const key = document.getElementById('nvs-add-key').value.trim();
            const type = document.getElementById('nvs-add-type').value;
            const value = document.getElementById('nvs-add-value').value.trim();

            if (!key) {
                alert('Please enter a key name.');
                return;
            }

            if (key.length > 15) {
                alert('Key name must be 15 characters or less.');
                return;
            }

            if (!value) {
                alert('Please enter a value.');
                return;
            }

            // Save partition index and namespace before closing dialog
            const partitionIdx = currentNVSAddPartition;
            const namespace = currentNVSAddNamespace;

            try {
                const partition = parser.partitions[partitionIdx];
                await parser.addNVSItem(partition, namespace, key, type, value);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Added NVS item: ${namespace}.${key}`, 'success');
            } catch (error) {
                alert('Error adding NVS item: ' + error.message);
            }
        }

        async function submitNVSEditDialog() {
            const oldKey = window.currentNVSEditKey;
            const type = document.getElementById('nvs-add-type').value;
            const value = document.getElementById('nvs-add-value').value.trim();

            if (!value) {
                alert('Please enter a value.');
                return;
            }

            // Save partition index and namespace before closing dialog
            const partitionIdx = currentNVSAddPartition;
            const namespace = currentNVSAddNamespace;

            try {
                const partition = parser.partitions[partitionIdx];

                // Delete old entry
                await parser.deleteNVSItem(partition, namespace, oldKey);
                console.log(`Deleted old NVS item: ${namespace}/${oldKey}`);

                // Add new entry with same key
                await parser.addNVSItem(partition, namespace, oldKey, type, value);
                console.log(`Added updated NVS item: ${namespace}/${oldKey} = ${value} (${type})`);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Updated NVS item: ${namespace}.${oldKey}`, 'success');
            } catch (error) {
                alert('Error updating NVS item: ' + error.message);
            }
        }

        async function submitNVSAddNamespaceDialog() {
            const namespaceName = document.getElementById('nvs-namespace-name').value.trim();

            if (!namespaceName) {
                alert('Please enter a namespace name.');
                return;
            }

            if (namespaceName.length > 15) {
                alert('Namespace name must be 15 characters or less.');
                return;
            }

            // Save partition index before closing dialog
            const partitionIdx = currentNVSAddPartition;

            try {
                const partition = parser.partitions[partitionIdx];
                await parser.addNVSNamespace(partition, namespaceName);
                console.log(`Added namespace: ${namespaceName}`);

                closeNVSAddDialog();

                // Ensure the details row is visible before parsing
                const detailsRow = document.getElementById(`details-${partitionIdx}`);
                if (detailsRow && !detailsRow.classList.contains('visible')) {
                    detailsRow.classList.add('visible');
                }

                parseNVSPartition(partitionIdx);
                updateMemoryMap();

                setDeviceStatus(`Created namespace: ${namespaceName}`, 'success');
            } catch (error) {
                alert('Error creating namespace: ' + error.message);
            }
        }
    </script>
</body>

</html>